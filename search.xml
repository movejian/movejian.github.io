<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7安装时引导错误以及解决方案</title>
    <url>/2019/11/19/Centos7%E5%AE%89%E8%A3%85%E6%97%B6%E5%BC%95%E5%AF%BC%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>Centos7安装时引导错误以及解决方案<br>使用U盘刻录方式安装CentOS7.6，但是发现安装初始化时候发生错误，本以为是U盘刻录或者是镜像的问题，但是反复刻录多遍仍然出错。后来在CentOS中文社区，发现使用UltraISO刻录安装时就可能出现初始化引导错误1.一般情况下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>文字不会出现在屏幕下方。当我们在安装选择界面，也就是选择U盘启动的第一个界面，该界面上有三个选项：<br>1、Install CentOS 7<br>2、Test this media &amp; install CentOS7<br>3、Troubleshooting </p>
<p>选择第一项<br>此时，按一下Tab键，将会出现在屏幕下方出现这一串文字</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</span><br></pre></td></tr></table></figure>

<p>然后将这行文字修改为</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quiet</span><br></pre></td></tr></table></figure>

<p>其中sdb4指是我的电脑设备上的U盘，sda指第一个挂载盘，sdb指第二个挂载盘，sdc指第三个挂载盘，依此类推。每台电脑上的USB挂载名称不一样，要视情况而定选择挂载盘。通常情况下，我们不知道U盘挂载名称，这时候，可以将文字改为</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img linux dd quiet</span><br></pre></td></tr></table></figure>

<p>回车后，屏幕会出现挂载盘选择的的界面，该界面会显示，挂载盘名称（DEVICE）、类型（TYPE）、标识（LABEL）等信息，通常情况下选择标识为CentOS的就OK，也可以一个一个试。这时候记下挂载盘名称，重启电脑，启动进入U盘，出现系统安装选择界面，按Tab键，修改</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:/dev/挂载盘名称 quiet</span><br></pre></td></tr></table></figure>
<p>此处的“挂载盘名称”是你程序所在U盘的名称。也就是你制作的“启动盘”名称，非“被安装盘符”<br>博主使用的是PE启动盘加载ISO文件<br>并且是使用的魔术师做的启动盘。ISO文件路径为：<code>U:\CEO/USMIMGS</code><br>所以我所书写的为</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda1:/CEO/USMIMGS/ quiet</span><br></pre></td></tr></table></figure>
<p>你们使用老毛桃制作的启动盘只需要修改为</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda1:/iso/ quiet</span><br></pre></td></tr></table></figure>

<p>部分华为服务器不太一样<code>/dev/sda4</code>真诡异</p>
<p>最后按Enter就能进入CentOS安装界面了。</p>
]]></content>
      <tags>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo如何迁移到新电脑</title>
    <url>/2022/08/21/Hexo%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这是曾经发生的事情，自己对于数据备份疏忽，导致Hexo的<code>source</code>丢失，只能重新搭建博客。。。。。</p>
<p>如何备份后续会更新，一切都是泪。。。。。</p>
<span id="more"></span> 
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>迁移到新电脑之后，发现以前的Hexo拉到本地是无法正常使用的，这时候查找资料寻找解决办法</p>
<p>由于旧电脑操作不当已经被格式化了，所有的源代码数据都已经被清除，所以我现在只能重新搭建博客</p>
<h3 id="需要做的事情"><a href="#需要做的事情" class="headerlink" title="需要做的事情"></a>需要做的事情</h3><ol>
<li><p>重新搭建博客</p>
</li>
<li><p>做好GIT备份</p>
</li>
<li><p>定期同步</p>
</li>
</ol>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>（有source等文件的情况下可以恢复）</p>
<h4 id="1-GIT上设置秘钥"><a href="#1-GIT上设置秘钥" class="headerlink" title="1. GIT上设置秘钥"></a>1. GIT上设置秘钥</h4><p>  安装git这里就不描述了，安装完成之后，我们在终端执行<code>ssh-keygen -t rsa -C &quot;movejian@qq.com&quot;</code></p>
<p>然后按三次回车，生成秘钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">$ ssh-<span class="attribute">keygen</span> -t rsa -C <span class="string">&quot;xxxx<span class="variable">@qq</span>.com&quot;</span>(你的邮箱地址) Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/xxxxxx/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>在<code>C:\Users\xxxx.ssh</code>下面，就可以看到秘钥了，<strong>id_rsa</strong>是私钥，千万不能泄露出去，<strong>id_rsa.pub是公钥</strong>，我们需要复制<strong>公钥</strong>里面的内容</p>
<p>进入<a href="https://github.com/">github</a> ，选择 <code>setting</code></p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/blog/images/20220821123613.png" alt="github设置"></p>
<p>选择<code>SSH and GPG keys</code></p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/blog/images/20220821123713.png" alt="key配置"></p>
<p>选择<code>New SSH key</code></p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/blog/images/20220821123810.png" alt="保存你的key到github"></p>
<p>填写好title, 复制 rsa_public 里面的内容，点击<code>Add</code>，输入密码即可完成秘钥建立</p>
<h4 id="2-安装node"><a href="#2-安装node" class="headerlink" title="2. 安装node"></a>2. 安装node</h4><p>  在<strong>GIT</strong>设置完成之后，我们下一步是准备好环境进行还原，首先我们需要进入 <a href="https://nodejs.cn/download/">node.js</a>的官网下载对应的安装包，比如下方的中文网站：</p>
<p> <a href="https://nodejs.cn/download/">node.js</a>官方中文地址：<a href="https://nodejs.cn/download/">https://nodejs.cn/download/</a></p>
<p>进入网站之后，我们需要下载对应的安装包进行安装，这里建议下LTS的版本。</p>
<p>安装完node之后，这里不要着急，先检测一下自己是否真的安装好了，使用下面三个命令检测自己是否具备环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line">Git --version</span><br></pre></td></tr></table></figure>

<h4 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h4><p>新版本的node基本包含了<code>npm</code>这一类的工具，我们也无需手动安装，另外这里也不建议使用<code>cnpm</code>安装，建议直接使用<code>npm</code>安装即可，我们依次敲入下面的命令即可。</p>
  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>如果你是用的<strong>苹果系统（MAC）</strong>在前面加上<code>sudo</code></p>
  <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  如果mac电脑在操作node命令的时候出现类似permission的字样，多半是没有权限，sudoy一下即可</p>
</blockquote>
<p>安装好了之后，这里可以使用如下的命令安装Hexo，同上，如果使用<strong>MAC</strong>电脑在前面加上<code>sudo</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h4 id="4-从GIT把备份拉到本地"><a href="#4-从GIT把备份拉到本地" class="headerlink" title="4. 从GIT把备份拉到本地"></a>4. 从GIT把备份拉到本地</h4><p>  这一个步骤就是使用git clone把之前的文章构建的备份拉到本地，比如这里个人的命令如下。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> clone -b hexo https://xxxx/hexo</span><br></pre></td></tr></table></figure>

<p>这一步完成之后，在本地有的只是一个对于hexo的基础架构，这时候还是不能执行hexo命令的，我们还需要执行 npm install 把node和hexo的依赖安装到当前的目录，生成对应的node_moudules 文件。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">npm</span> install</span><br></pre></td></tr></table></figure>

<p>安装完成之后，我们就可以快乐的玩耍了。</p>
<h4 id="5-Hexo基础操作"><a href="#5-Hexo基础操作" class="headerlink" title="5. Hexo基础操作"></a>5. Hexo基础操作</h4><p>好久没有用过了，这里再次回顾一下基础的操作，其实hexo到了最后就只剩下几个操作就可以完成，比如下面的命令，把笔记软件写好的稿子放到hexo生成的文件里面，加一个<code>&lt;!-- more --&gt;</code>标签即可完成一遍笔记的输出，然后部署上去之后自动推送到github和gitee 的分支。</p>
  <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> new <span class="string">&#x27;xxx&#x27;</span>//新建一个新的主题</span><br><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>  个人喜欢使用如下的文章模板：</p>
  <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; <span class="attribute">title</span> &#125;&#125;</span><br><span class="line">subtitle: <span class="string">&#x27;这个人很懒，不想写副标题&#x27;</span></span><br><span class="line">author: lazytime</span><br><span class="line">url_suffix: random</span><br><span class="line">date: &#123;&#123; <span class="attribute">date</span> &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- 无</span><br><span class="line">categories:</span><br><span class="line">- 未分类</span><br><span class="line">keywords: 请输入关键字（英文逗号分隔多个关键字）</span><br><span class="line">description: 请输入描述信息</span><br><span class="line">copyright: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  备份还原还是非常快的，中间除了在node的权限上卡了一下，基本上不到半小时既可以在本地快速搭建一个hexo的博客，十分方便。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>建议每一个人有一个自己的博客，因为你不知道你的云笔记运营商哪一天会出问题，就好比之前的滴滴事件一样，另外注意平时多备份，不要像我一样傻不拉几的把硬盘格式化结果忘了把博客的内容拷出来结果全部要重写。。。。。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的挂载命令mount</title>
    <url>/2022/09/21/Linux%E4%B8%AD%E7%9A%84%E6%8C%82%E8%BD%BD%E5%91%BD%E4%BB%A4mount/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Linux GUI 中，我们通常理所当然地认为，当我们插入 USB 闪存驱动器、硬盘驱动器甚至 DVD 磁盘时，它们就可以使用了。但是在后台有一个过程，设备被安装（准备好使用）并分配了一个安装点。当使用服务器或远程连接时，并不能确定某个设备是否会自动可用，那么我们如何挂载自己的设备呢？下面我们一起来看一下！</p>
<span id="more"></span>
<h3 id="mount是什么？"><a href="#mount是什么？" class="headerlink" title="mount是什么？"></a>mount是什么？</h3><p>Linux文件系统中的所有文件都以<code>/ </code>为根的大树的形式排列。这些文件可以根据您的分区表分布在各种设备上，最初你的父目录安装（即附加）到这棵树的<code>/</code> ，其他的可以手动挂载使用<code>GUI</code>界面（如果可用）或使用挂载命令。</p>
<p><code>mount</code>命令用于将设备上找到的文件系统挂载到以 <code>/</code> 为根的大树结构（Linux文件系统）上。相反，另一个命令<code>umount</code>可用于从树中分离这些设备。</p>
<h3 id="mount的初级用法"><a href="#mount的初级用法" class="headerlink" title="mount的初级用法"></a>mount的初级用法</h3><p><code>mount</code>命令挂载存储设备或文件系统，使其可访问并将其附加到现有目录结构。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t 类型设备目录</span><br></pre></td></tr></table></figure>

<p>这告诉内核将设备上找到的文件系统（类型为type）附加到目录<code>dir</code>。<code>dir</code>之前的内容（如果有）、<code>owner</code>和<code>mode</code>变得不可见，只要这个文件系统保持挂载，路径名dir指的是设备上文件系统的根目录。如果没有提到目标目录，默认情况下，它将设备挂载在 <code>/etc/fstab</code> 文件中。</p>
<h4 id="其他形式："><a href="#其他形式：" class="headerlink" title="其他形式："></a>其他形式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount [-l|-h|-V]</span><br><span class="line">mount -a [-fFnrsvw] [-t fstype] [-O optlist]</span><br><span class="line">mount [-fnrsvw] [-o options] device|dir</span><br><span class="line">mount [-fnrsvw] [-t fstype] [-o options] device dir</span><br></pre></td></tr></table></figure>

<p>这些命令告诉内核将在设备上找到的文件系统附加到<code>dir</code>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>要将硬盘驱动器的第二个分区挂载到现有目录<code>/media/PHOTOS</code>（挂载点）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mount /dev/hda2 /media/PHOTOS</span><br></pre></td></tr></table></figure>

<p> 显示所有已安装的分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mount</span><br><span class="line">proc on /proc type proc (rw) </span><br><span class="line">sysfs on /sys type sysfs (rw) </span><br><span class="line">devpts on /dev/pts type devpts (rw,gid=5,mode=620) </span><br><span class="line">/dev/sda1 on /boot type ext3 (rw ) </span><br><span class="line">/tmp on /var/tmp type none (rw,noexec,nosuid,bind) </span><br><span class="line">10.4.0.4:/srv/export/setup_server on /nfs/setup_server type nfs (ro,addr=10.4.0.4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要卸载刚才的分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ umount /dev/hda2</span><br></pre></td></tr></table></figure>

<p>参照挂载点卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ umount /media/PHOTOS</span><br></pre></td></tr></table></figure>

<p>使用特定选项重新挂载分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mount -o remount,rw /dev/hda2</span><br></pre></td></tr></table></figure>

<h3 id="umount的初级用法"><a href="#umount的初级用法" class="headerlink" title="umount的初级用法"></a>umount的初级用法</h3><p><code>umount</code>命令从文件层次结构中分离指定的文件系统。一个文件系统是通过给出它被安装的目录来指定的。提供文件系统所在的特殊设备也可以工作，但这是一种过时的方法，主要是因为如果该设备安装在多个目录上，它会失败。</p>
<p>但是需要注意，文件系统在繁忙时无法卸载 。例如，当它上面有打开的文件时，或者当某个进程在那里有它的工作目录时，或者当它上面的交换文件正在使用时，<code>umount</code>将无法成功。</p>
<p>有些无法使用<code>umount</code>的进程甚至可能是<code>umount</code>本身——例如，<code>umount</code>打开公共C库，而后者又可能打开了语言环境文件，如果它们在相关设备上，则会阻止它被卸载。即使出现这种冲突，“惰性”卸载（参见下面卸载选项部分中的-l ）也会尝试卸载。</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ul>
<li>显示有关已安装文件系统的信息：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210149077.png"></p>
<ul>
<li>挂载文件系统：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210150279.png"></p>
<ul>
<li><p>显示版本信息：</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210151979.png"></p>
</li>
<li><p>卸载文件系统：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210151025.png"></p>
<h3 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h3><p>绑定挂载允许将文件系统层次结构或文件挂载到不同的挂载点。与符号链接不同，文件系统本身不存在绑定挂载。在下面的例子中，路径&#x2F;olddir将被挂载在<code>/newdir</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mount --bind /olddir /newdir</span><br></pre></td></tr></table></figure>

<h3 id="如何在-Linux-上挂载和卸载驱动器"><a href="#如何在-Linux-上挂载和卸载驱动器" class="headerlink" title="如何在 Linux 上挂载和卸载驱动器"></a>如何在 Linux 上挂载和卸载驱动器</h3><p>可以使用终端安装 SSD、USB 闪存驱动器、HDD 和 ISO 映像。在终端仿真器中使用命令行界面 (CLI) 可以让我们更好地控制何时安装驱动器以及它们在文件系统中的安装位置。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210123639.png"></p>
<ol>
<li>使用<code>lsblk</code>命令识别 USB 驱动器。在结果中，您可能会看到许多标记为“循环”的条目。但是，您正在寻找被列为<code>sda</code>或<code>sdb</code>的结果，以识别连接到您的系统的物理磁盘。比较所连接驱动器的列出容量通常可以帮助您发现目标驱动器的名称。在我们的例子中，我们可以将 USB 驱动器识别为 <code>sdb1</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210123811.png"></p>
<ol start="2">
<li>创建一个目录来挂载 USB 驱动器。当外部驱动器自动挂载时，它通常挂载在媒体目录中。但是使用 CLI，我们可以创建并指定一个目录，我们将在其中挂载我们的 <code>pendrive</code>。请注意，我们需要使用<code>sudo</code>来调用<code>root</code>权限，以便在媒体目录中创建一个目录。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /media/pendrive</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>mount</code>命令将 U 盘挂载到<code>/media/pendrive</code>目录。<code>mount</code>命令具有以下语法；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sdb1 /media/pendrive</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>通过重新运行<code>lsblk</code>检查驱动器是否已安装。</p>
<blockquote>
<p>请注意， <code>lsblk</code>输出中的最后一列列出了列出设备的挂载点，如果列出了挂载点，则确认该设备已挂载。</p>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210124550.png"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>使用<code>mount</code>命令我们可以更好地控制在 Linux 中挂载和卸载磁盘，并掌握一些技巧，在连接的驱动器无法自动正确挂载时可能会有所帮助。</p>
<p>在探索以前使用的系统的旧备份映像或想要查看 Linux 发行版映像内容以进行探索或学习时，能够使用循环设备挂载磁盘映像非常有用。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看硬件信息与系统资源</title>
    <url>/2022/09/06/Linux%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>Linux下经常需要查看系统资源或硬件资源，与之对应的命令行也是非常多</p>
<p>本文将根据使用经验，将常见的查询方法总结罗列一遍以供参考</p>
<p>以下指令以Ubuntu1804、Cent7OS作为测试平台</p>
<h2 id="1-系统资源"><a href="#1-系统资源" class="headerlink" title="1. 系统资源"></a>1. 系统资源</h2><h3 id="1-1-Linux发行版与内核"><a href="#1-1-Linux发行版与内核" class="headerlink" title="1.1. Linux发行版与内核"></a>1.1. Linux发行版与内核</h3><p><code>uname -r</code>命令输出发行版与内核信息，大部分发行版基本均带有此命令，但输出中未必包含发行版全称信息</p>
<span id="more"></span>
<p>Cent7OS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[chancel@localhost ~]$ uname -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-1160.62.1.el7.x86_64 #1 SMP Tue Apr 5 16:57:59 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>Ubuntu1804</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ uname -a</span><br><span class="line">Linux ubuntu1804 4.15.0-189-generic #200-Ubuntu SMP Wed Jun 22 19:53:37 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p><code>cat /proc/version</code>命令输出内核版本与编译的gcc版本</p>
<p>Cent7OS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[chancel@localhost ~]$ cat /proc/version </span><br><span class="line">Linux version 3.10.0-1160.62.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Tue Apr 5 16:57:59 UTC 2022</span><br></pre></td></tr></table></figure>

<p>Ubuntu1804</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cat /proc/version</span><br><span class="line">Linux version 4.15.0-189-generic (buildd@lcy02-amd64-039) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #200-Ubuntu SMP Wed Jun 22 19:53:37 UTC 2022</span><br></pre></td></tr></table></figure>

<p><code>lsb_release -a</code>命令输出发行版信息，但Cent7OS并不包含此命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 18.04.6 LTS</span><br><span class="line">Release:        18.04</span><br><span class="line">Codename:       bionic</span><br></pre></td></tr></table></figure>

<p><code>cat /etc/redhat-release</code>命令是Redhat系列独有的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[chancel@localhost ~]$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br></pre></td></tr></table></figure>

<p><code>cat /etc/*release</code>命令在大部分Linux发行版中都可以使用，是最方便使用的命令</p>
<p>以Cent7OS为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[chancel@localhost ~]$ cat /etc/*release</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">...</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-CPU-x2F-内存占用查看"><a href="#1-2-CPU-x2F-内存占用查看" class="headerlink" title="1.2. CPU&#x2F;内存占用查看"></a>1.2. CPU&#x2F;内存占用查看</h3><p><code>top</code>指令是最常见用于检测CPU占用情况的指令，使用效果如下</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209081929349.png" alt="img"></p>
<p>此时按<code>P</code>以CPU占用排序，按<code>M</code>以内存占用排序，按<code>I</code>隐藏所有空闲进程，按<code>S</code>以运行时间排序</p>
<p><code>htop</code>指令则是比<code>top</code>更简洁的显示程序，在部分发行版上需要自行安装，使用效果如下</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209081930961.png" alt="img"></p>
<p>相较于<code>top</code>的使用，<code>htop</code>界面更清晰易懂，使用方法在界面均有提示，对用户更为友好</p>
<p>通常情况下，<code>htop</code>需要自行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu</span><br><span class="line">sudo apt install htop</span><br><span class="line"></span><br><span class="line"># Cent</span><br><span class="line">sudo yum install htop</span><br></pre></td></tr></table></figure>

<p><code>glances</code>则是比<code>htop</code>更进一步的资源查看器</p>
<p>不但包括常见的CPU、内存，甚至还包括当前网速以及硬件温度数据，使用效果如下</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209081931536.png" alt="img"></p>
<p>通常情况下，<code>glances</code>需要自行安装，由于是使用Python语言开发的，所以资源占用也较大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu</span><br><span class="line">sudo apt install glances</span><br><span class="line"></span><br><span class="line"># Cent</span><br><span class="line">sudo yum install glances</span><br></pre></td></tr></table></figure>

<p>以上3个是我比较常用的系统资源占用查询工具，大部分情况下都非常够用</p>
<p>其他的可能还包括<code>nmon</code>、<code>vmstat</code>等，若有兴趣也可自行查询</p>
<h3 id="1-3-磁盘资源管理"><a href="#1-3-磁盘资源管理" class="headerlink" title="1.3. 磁盘资源管理"></a>1.3. 磁盘资源管理</h3><p><code>df -h</code>通常用于查询硬盘资源使用情况（-h代表使用以1024为单位且易读的方式显示）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs           395M  1.3M  394M   1% /run</span><br><span class="line">/dev/vda2       126G   57G   63G  48% /</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0      114M  114M     0 100% /snap/core/13425</span><br><span class="line">/dev/loop1      114M  114M     0 100% /snap/core/13308</span><br><span class="line">tmpfs           395M     0  395M   0% /run/user/1000</span><br></pre></td></tr></table></figure>

<p><code>fdisk -l</code>则是用于查询物理分区情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo fdisk -l</span><br><span class="line">Disk /dev/loop0: 114 MiB, 119525376 bytes, 233448 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/loop1: 113.9 MiB, 119418880 bytes, 233240 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 128 GiB, 137438953472 bytes, 268435456 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 376C8DD5-F786-4C39-9F4E-1461BE1FA269</span><br><span class="line"></span><br><span class="line">Device     Start       End   Sectors  Size Type</span><br><span class="line">/dev/vda1   2048      4095      2048    1M BIOS boot</span><br><span class="line">/dev/vda2   4096 268433407 268429312  128G Linux filesystem</span><br></pre></td></tr></table></figure>

<p>当然，<code>fdisk</code>命令本身主要还是用于管理硬盘分区，其管理过程是对话式的，类似于下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[chancel@localhost ~]$ sudo fdisk /dev/vda</span><br><span class="line">[sudo] password for chancel: </span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure>

<p>输入<code>m</code>可获得指令帮助，创建过程非常简单易懂</p>
<p><code>mkfs.[format]</code>命令用于格式化硬盘，<code>[format]</code>代表硬盘格式，常见的格式如下</p>
<ul>
<li>mkfs.ext2</li>
<li>mkfs.ext3</li>
<li>mkfs.ext4</li>
<li>mkfs.ntfs</li>
<li>mkfs.xfs</li>
</ul>
<p>在分区成功后，通常需要格式化，使用<code>mkfs.[format] /dev/[device_name]</code>进行格式化</p>
<h3 id="1-4-网络信息管理"><a href="#1-4-网络信息管理" class="headerlink" title="1.4. 网络信息管理"></a>1.4. 网络信息管理</h3><p><code>ip</code>是常用的网络信息查看工具，是后期Linux用于替换<code>ipconfig</code>的工具</p>
<p>常见的用法</p>
<ul>
<li><code>ip addr show</code>显示网路ip信息（缩写<code>ip a</code>）</li>
<li><code>ip link show</code>显示网络接口信息（缩写<code>ip l</code>）</li>
<li><code>ip route list</code>显示网路路由信息（缩写<code>ip r</code>）</li>
<li><code>ip neigh show</code>显示网路ARP表信息（缩写<code>ip n</code>）</li>
</ul>
<p><code>ip addr</code>通常用于设置网卡的网络信息，如</p>
<ul>
<li><code>ip addr &#123;add|change|del&#125; 172.16.0.1/24 dev eth0</code>添加&#x2F;更改&#x2F;删除网卡ip</li>
</ul>
<p><code>ip link</code>通常用于控制网卡的行为，如</p>
<ul>
<li><code>ip link set eth0 &#123;up/down&#125;</code>用于开启关闭网卡</li>
<li><code>ip link set eth0 promisc &#123;on/off&#125;</code>用于设置网卡混杂模式开启关闭</li>
</ul>
<p><code>ip route</code>通常用于设置路由信息，如</p>
<ul>
<li><code>ip route &#123;add/del&#125; [ip_address] via [gateway]</code>添加&#x2F;删除网关静态路由</li>
<li><code>ip route &#123;add/del&#125; [ip_address] dev [interface]</code>添加&#x2F;删除接口静态路由</li>
</ul>
<p><code>ip neigh</code>通常用于王路平arp表（替换老旧的<code>arp</code>命令），如</p>
<ul>
<li><code>ip neigh &#123;add/dev&#125; [ip_address] dev [interface]</code>添加&#x2F;删除一个arp映射</li>
</ul>
<p>比较常用的是<code>ip addr</code>与<code>ip route</code>2个参数</p>
<p>前者用于查询网络ip信息，其输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ ➤ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:de:23:94:48 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 209.141.42.231/24 brd 209.141.42.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 2591984sec preferred_lft 2591984sec</span><br><span class="line">    inet6 fe80::216:deff:fe23:9448/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>后者常用于规划路由请求，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置路由走网关172.16.0.1，得到公网IP为4.4.4.4</span><br><span class="line">➜  ~ ip route add 104.160.18.230 via 172.16.0.1</span><br><span class="line">➜  ~ curl https://api.chancel.me/rest/api/v1/ip</span><br><span class="line">&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;Query success&quot;,&quot;data&quot;:&#123;&quot;ip&quot;:&quot;4.4.4.4&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 设置路由走网关192.168.1.1，得到公网IP为6.6.6.6</span><br><span class="line">➜  ~ ip route del 104.160.18.230 via 192.168.1.1</span><br><span class="line">➜  ~ curl https://api.chancel.me/rest/api/v1/ip</span><br><span class="line">&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;Query success&quot;,&quot;data&quot;:&#123;&quot;ip&quot;:&quot;6.6.6.6&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-硬件资源"><a href="#2-硬件资源" class="headerlink" title="2. 硬件资源"></a>2. 硬件资源</h2><h3 id="2-1-CPU信息"><a href="#2-1-CPU信息" class="headerlink" title="2.1. CPU信息"></a>2.1. CPU信息</h3><p><code>lscpu</code>和<code>cat /proc/cpuinfo</code>都可以输出CPU信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lscpu   </span><br><span class="line">Architecture:            x86_64</span><br><span class="line">  CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">  Address sizes:         48 bits physical, 48 bits virtual</span><br><span class="line">  ...</span><br><span class="line">Vulnerabilities:         </span><br><span class="line">  ...</span><br><span class="line">  Tsx async abort:       Not affected</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存信息"><a href="#2-2-内存信息" class="headerlink" title="2.2. 内存信息"></a>2.2. 内存信息</h3><p><code>lsmem</code>和<code>cat /proc/meminfo</code>都可以输出内存信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lsmem       </span><br><span class="line">RANGE                                 SIZE  STATE REMOVABLE  BLOCK</span><br><span class="line">0x0000000000000000-0x00000000bfffffff   3G online       yes   0-23</span><br><span class="line">0x0000000100000000-0x0000000f3fffffff  57G online       yes 32-487</span><br><span class="line"></span><br><span class="line">Memory block size:       128M</span><br><span class="line">Total online memory:      60G</span><br><span class="line">Total offline memory:      0B</span><br></pre></td></tr></table></figure>

<h3 id="2-3-硬盘信息"><a href="#2-3-硬盘信息" class="headerlink" title="2.3. 硬盘信息"></a>2.3. 硬盘信息</h3><p><code>lsblk</code>用于查看硬盘信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lsblk       </span><br><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0         7:0    0     4K  1 loop /var/lib/snapd/snap/bare/5</span><br><span class="line">...</span><br><span class="line">loop8         7:8    0    47M  1 loop /var/lib/snapd/snap/snapd/16292</span><br><span class="line">sda           8:0    0 476.9G  0 disk </span><br><span class="line">└─sda1        8:1    0 476.9G  0 part /mnt/SDA</span><br><span class="line">nvme0n1     259:0    0 931.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   300M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p2 259:2    0 866.5G  0 part /</span><br><span class="line">└─nvme0n1p3 259:3    0  64.7G  0 part [SWAP]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-USB信息"><a href="#2-4-USB信息" class="headerlink" title="2.4. USB信息"></a>2.4. USB信息</h3><p><code>lsusb</code>用于查看USB接口信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lsusb -t</span><br><span class="line">/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/2p, 10000M</span><br><span class="line">/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 480M</span><br><span class="line">    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M</span><br><span class="line">    |__ Port 1: Dev 2, If 1, Class=Human Interface Device, Driver=usbhid, 12M</span><br><span class="line">    |__ Port 2: Dev 3, If 0, Class=Hub, Driver=hub/4p, 480M</span><br><span class="line">        |__ Port 2: Dev 4, If 0, Class=Human Interface Device, Driver=usbhid, 12M</span><br><span class="line">        |__ Port 2: Dev 4, If 1, Class=Human Interface Device, Driver=usbhid, 12M</span><br><span class="line">        |__ Port 2: Dev 4, If 2, Class=Human Interface Device, Driver=usbhid, 12M</span><br><span class="line">/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/2p, 10000M</span><br><span class="line">/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 480M</span><br></pre></td></tr></table></figure>

<h3 id="2-5-lspci"><a href="#2-5-lspci" class="headerlink" title="2.5. lspci"></a>2.5. lspci</h3><p><code>lspci</code>用于提取主板上所有的硬件信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lspci</span><br><span class="line">00:00.0 Host bridge: Advanced Micro Devices, Inc. [AMD] Renoir/Cezanne Root Complex</span><br><span class="line">00:00.2 IOMMU: Advanced Micro Devices, Inc. [AMD] Renoir/Cezanne IOMMU</span><br><span class="line">...</span><br><span class="line">03:00.6 Audio device: Advanced Micro Devices, Inc. [AMD] Family 17h/19h HD Audio Controller</span><br><span class="line">04:00.0 SATA controller: Advanced Micro Devices, Inc. [AMD] FCH SATA Controller [AHCI mode] (rev 81)</span><br></pre></td></tr></table></figure>

<p>如果需要更详细的pci信息，可以使用<code>lspci -v</code>或<code>lspci -vv</code></p>
<p><code>lspci</code>通常配合<code>grep</code>用于筛查硬件信息，如<code>lspci | grep -i eth</code>可查看网络接口情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ lspci | grep -i eth</span><br><span class="line">02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)</span><br></pre></td></tr></table></figure>

<h2 id="3-高级命令"><a href="#3-高级命令" class="headerlink" title="3. 高级命令"></a>3. 高级命令</h2><p>以下命令相较于上面的命令来说，能更加全面的显示系统资源与硬件信息</p>
<h3 id="3-1-netstat"><a href="#3-1-netstat" class="headerlink" title="3.1. netstat"></a>3.1. netstat</h3><p><code>netstat</code>用于监控tcp&#x2F;ip连接信息，常用于查找某个端口的占用程序</p>
<p>如<code>netstat -anp | grep 8384</code>便可以查询出占用8384端口的程序PID</p>
<p><code>-a</code>代表列出所有，<code>-n</code>代表禁用反向域名解析，<code>-p</code>代表打印程序PID</p>
<p>效果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ netstat -atp | grep 8384</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 localhost:8384          0.0.0.0:*               LISTEN      817/syncthing</span><br></pre></td></tr></table></figure>

<p>使用<code>-l</code>参数，可以显示所有正在监听端口的服务程序，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ netstat -tnlp</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:8384          0.0.0.0:*               LISTEN      817/syncthing       </span><br><span class="line">...   </span><br><span class="line">tcp6       0      0 :::42103                :::*                    LISTEN      796/client_linux_am</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>-p</code>参数打印出PID，但ROOT用户运行的程序普通用户无法探查其PID，故看情况需要决定是否使用<code>sudo</code></p>
</blockquote>
<p><code>netstat</code>也可打印网络接口信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ netstat -ie</span><br><span class="line">Kernel Interface table</span><br><span class="line">enp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.4.12  netmask 255.255.240.0  broadcast 192.168.15.255</span><br><span class="line">        inet6 fd1c:b796:b00f:3f00:28a8:42ce:82e2:eda1  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::fea6:9f63:51a6:3dc0  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        inet6 240e:47c:630:64d9:b23c:f504:1008:88df  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        ether 5a:bc:da:6d:f1:09  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 4480503  bytes 2392967850 (2.2 GiB)</span><br><span class="line">        RX errors 0  dropped 1093  overruns 0  frame 0</span><br><span class="line">        TX packets 2206930  bytes 246464482 (235.0 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 231260  bytes 482760756 (460.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 231260  bytes 482760756 (460.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p><code>netstat</code>具备非常多的网络高级操作功能，若有兴趣，可参考<code>man netstat</code>进行学习</p>
<h3 id="3-2-lsof"><a href="#3-2-lsof" class="headerlink" title="3.2. lsof"></a>3.2. lsof</h3><p>在Linux中，一切皆是文件</p>
<p><code>lsof</code>(list open files)是一个列出当前操作系统打开文件的工具，所以<code>lsof</code>可以做到非常多的事情</p>
<p>直接使用<code>lsof</code>会显示当前系统所有正打开的文件，由于长时间运行的操作系统拥有多个进程，单纯使用<code>lsof</code>的操作较少</p>
<p><code>lsof</code>常用于查询资源占用情况，如</p>
<ul>
<li><code>lsof -c syncthing</code>显示进程syncthing正在使用的资源</li>
<li><code>lsof -c -p 817</code>显示PID为817的进程正在使用的资源</li>
<li><code>lsof +d /tmp</code>显示正在使用<code>/tmp</code>目录的进程列表</li>
<li><code>lsof -i :8384</code>显示正在使用端口8384的进程</li>
</ul>
<p><code>lsof</code>适用场景非常广泛，如</p>
<ul>
<li>无法卸载文件系统时显示<code>/mnt/sda target is busy</code>，可以使用<code>lsof /mnt/sda</code>查看是什么进程正在占用目录</li>
<li>无法启动监听端口8080程序时，可以使用<code>lsof -i :8080</code>查看是什么进程占用了端口8080</li>
<li>…</li>
</ul>
<h3 id="3-3-lshw"><a href="#3-3-lshw" class="headerlink" title="3.3. lshw"></a>3.3. lshw</h3><p><code>lshw</code>命令常用于输出机器配置摘要，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lshw -html &gt; my-hardware.html</span><br></pre></td></tr></table></figure>

<p>除了html报告可选外，还有<code>-json</code>、<code>-xml</code>等格式可选</p>
<p><code>-short</code>参数查看简略报告，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo lshw -short</span><br><span class="line">H/W path              Device          Class       Description</span><br><span class="line">=============================================================</span><br><span class="line">                                      system      To Be Filled By O.E.M. (To Be Filled By O.E.M.)</span><br><span class="line">/0                                    bus         X300M-STX</span><br><span class="line">...</span><br><span class="line">/0/4                                  system      Motherboard registers</span><br><span class="line">/0/5                                  system      Motherboard registers</span><br></pre></td></tr></table></figure>

<p><code>-class</code>参数可指定查看部分硬件信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo lshw -class cpu -class disk</span><br><span class="line">  *-cpu                     </span><br><span class="line">       description: CPU</span><br><span class="line">       product: AMD Ryzen 7 PRO 4750G with Radeon Graphics</span><br><span class="line">       vendor: Advanced Micro Devices [AMD]</span><br><span class="line">       ...</span><br><span class="line">       sectorsize=512 wwid=eui.0025385211918242</span><br><span class="line">  *-disk</span><br><span class="line">       description: ATA Disk</span><br><span class="line">       ...</span><br><span class="line">       logicalsectorsize=512 sectorsize=512</span><br></pre></td></tr></table></figure>

<h3 id="3-4-inxi（推荐）"><a href="#3-4-inxi（推荐）" class="headerlink" title="3.4. inxi（推荐）"></a>3.4. inxi（推荐）</h3><p><code>inxi</code>用于获取所有硬件与系统信息，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ inxi</span><br><span class="line">CPU: 8-core AMD Ryzen 7 PRO 4750G with Radeon Graphics (-MT MCP-)</span><br><span class="line">speed/min/max: 1594/1400/4454 MHz Kernel: 5.19.0-1-MANJARO x86_64 Up: 6h 43m</span><br><span class="line">Mem: 11918.5/60152.7 MiB (19.8%) Storage: 1.38 TiB (22.2% used) Procs: 416</span><br><span class="line">Shell: Zsh inxi: 3.3.19</span><br></pre></td></tr></table></figure>

<p><code>-M</code>参数可用于获取机器硬件品牌信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ inxi -M</span><br><span class="line">Machine:</span><br><span class="line">  Type: Desktop Mobo: ASRock model: X300M-STX serial: &lt;superuser required&gt;</span><br><span class="line">    UEFI: American Megatrends LLC. v: P1.70 date: 07/01/2021</span><br></pre></td></tr></table></figure>

<p>获取单个硬件有以下参数</p>
<ul>
<li><code>-C</code>CPU信息</li>
<li><code>-A</code>声卡信息</li>
<li><code>-N</code>网卡信息</li>
<li><code>-D</code>硬盘信息</li>
<li><code>-s</code>传感器温度与风扇转速</li>
</ul>
<p>获取系统资源信息有以下参数</p>
<ul>
<li><code>-p</code>硬盘分区信息</li>
<li><code>-I</code>进程数以及开机时间等信息</li>
<li><code>-t</code>显示5个最占用CPU&#x2F;内存的应用（使用<code>cm10</code>可修改成前10个）</li>
<li><code>-n</code>网络接口信息</li>
<li><code>-r</code>软件仓库信息</li>
</ul>
<p>同样<code>inxi</code>也支持输出机器配置报告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ inxi -b</span><br><span class="line">System:</span><br><span class="line">  Host: KDE-Manjaro-64G Kernel: 5.19.0-1-MANJARO arch: x86_64 bits: 64</span><br><span class="line">    ...</span><br><span class="line">  Shell: Zsh inxi: 3.3.19</span><br></pre></td></tr></table></figure>

<p>下面是比较全面的输出机器硬件与软件信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ inxi -Fza           </span><br><span class="line">System:</span><br><span class="line">  Kernel: 5.19.0-1-MANJARO arch: x86_64 bits: 64 compiler: gcc v: 12.1.0</span><br><span class="line">    parameters: BOOT_IMAGE=/boot/vmlinuz-5.19-x86_64</span><br><span class="line">    root=UUID=2ddecb6a-da82-48f6-9f5a-d810b32d623b rw quiet apparmor=1</span><br><span class="line">    security=apparmor resume=UUID=406e14e5-7ca3-4959-bb61-8bf9158da6f9</span><br><span class="line">    udev.log_priority=3</span><br><span class="line">  Desktop: KDE Plasma v: 5.24.6 tk: Qt v: 5.15.5 wm: kwin_x11 vt: 1</span><br><span class="line">    dm: SDDM Distro: Manjaro Linux base: Arch Linux</span><br><span class="line">Machine:</span><br><span class="line">  Type: Desktop Mobo: ASRock model: X300M-STX serial: &lt;superuser required&gt;</span><br><span class="line">    UEFI: American Megatrends LLC. v: P1.70 date: 07/01/2021</span><br><span class="line">CPU:</span><br><span class="line">  Info: model: AMD Ryzen 7 PRO 4750G with Radeon Graphics bits: 64</span><br><span class="line">...</span><br><span class="line">Info:</span><br><span class="line">  Processes: 416 Uptime: 6h 52m wakeups: 0 Memory: 58.74 GiB</span><br><span class="line">  used: 11.55 GiB (19.7%) Init: systemd v: 251 default: graphical</span><br><span class="line">  tool: systemctl Compilers: gcc: 12.1.0 clang: 14.0.6 Packages: 1707</span><br><span class="line">  pacman: 1701 lib: 372 flatpak: 0 snap: 6 Shell: Zsh v: 5.9</span><br><span class="line">  running-in: konsole inxi: 3.3.19</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo迁移备份</title>
    <url>/2022/08/21/Hexo%E8%BF%81%E7%A7%BB%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h3 id="创建Git分支将Hexo博客迁移到其它电脑"><a href="#创建Git分支将Hexo博客迁移到其它电脑" class="headerlink" title="创建Git分支将Hexo博客迁移到其它电脑"></a>创建Git分支将Hexo博客迁移到其它电脑</h3><h3 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h3><p>有时候就会干些蠢事，换电脑忘记吧旧电脑博客的Hexo博客备份到移动硬盘上，一个格式化啥都没了，导致丢失了所有的博客资料。（博客内容要慢慢补） 一定要养成经常备份的好习惯。。。。。。。。</p>
<span id="more"></span>
<h3 id="迁移前准备：安装hexo博客必要的软件"><a href="#迁移前准备：安装hexo博客必要的软件" class="headerlink" title="迁移前准备：安装hexo博客必要的软件"></a>迁移前准备：安装hexo博客必要的软件</h3><ul>
<li>下载安装Git客户端</li>
<li>安装node js</li>
<li>从git 仓库拉去原来的项目</li>
</ul>
<h3 id="采取方式"><a href="#采取方式" class="headerlink" title="采取方式"></a>采取方式</h3><ol>
<li>采取新建仓库的方式</li>
<li>分支存放源代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone 你的 github 博客地址，这里就不给地址给自己打广告了</span><br></pre></td></tr></table></figure>

<h3 id="必备文件"><a href="#必备文件" class="headerlink" title="必备文件"></a>必备文件</h3><table>
<thead>
<tr>
<th>文件(夹)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scaffolds&#x2F;</td>
<td>博客文章模板</td>
</tr>
<tr>
<td>source&#x2F;</td>
<td>所有的博客文章</td>
</tr>
<tr>
<td>themes&#x2F;</td>
<td>网站主题</td>
</tr>
<tr>
<td>.gitignore</td>
<td>push时需忽略的文件</td>
</tr>
<tr>
<td>package.json</td>
<td>依赖包的名称和版本号</td>
</tr>
</tbody></table>
<h3 id="备份流程"><a href="#备份流程" class="headerlink" title="备份流程"></a>备份流程</h3><h5 id="1-拉取已经部署上去的项目"><a href="#1-拉取已经部署上去的项目" class="headerlink" title="1. 拉取已经部署上去的项目"></a>1. 拉取已经部署上去的项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lazyTimes/lazyTimes.github.io.git</span><br></pre></td></tr></table></figure>

<h5 id="2-拷贝需要备份的-原数据"><a href="#2-拷贝需要备份的-原数据" class="headerlink" title="2. 拷贝需要备份的 原数据"></a>2. 拷贝需要备份的 <font color="#000066">原数据</font></h5><p>具体查看上方的必备文件</p>
<p>参考截图:</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208211351777.png" alt="image-20220821135153686"></p>
<h5 id="3-删除主题的-git-配置"><a href="#3-删除主题的-git-配置" class="headerlink" title="3. 删除主题的.git 配置"></a>3. 删除主题的.git 配置</h5><p>执行如下命令删除不必要的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure>

<h5 id="4-创建名为hexo的分支"><a href="#4-创建名为hexo的分支" class="headerlink" title="4. 创建名为hexo的分支"></a>4. 创建名为hexo的分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure>

<h5 id="5-把文件存放到暂存区"><a href="#5-把文件存放到暂存区" class="headerlink" title="5. 把文件存放到暂存区"></a>5. 把文件存放到暂存区</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<h5 id="6-提交变更"><a href="#6-提交变更" class="headerlink" title="6. 提交变更"></a>6. 提交变更</h5><p>先提交所有的改动内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;hexo-2&quot;</span><br></pre></td></tr></table></figure>

<p>然后使用如下命令把内容推送到分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有在Git config 设置用户名和密码，推送的时候会提示设置，根据提示设置用户名和密码即可</p>
</blockquote>
<h5 id="7-源码推到分支上"><a href="#7-源码推到分支上" class="headerlink" title="7. 源码推到分支上"></a>7. 源码推到分支上</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;xxxx&quot;</span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure>

<h3 id="更加推荐的方式"><a href="#更加推荐的方式" class="headerlink" title="更加推荐的方式"></a>更加推荐的方式</h3><p>为了保证我们的源码的一些敏感配置不泄露，建议使用私有仓库进行存储，然而，我是无所谓&#x3D;-&#x3D;</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统无线网卡配置</title>
    <url>/2019/12/16/Linux%E7%B3%BB%E7%BB%9F%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="无线网卡配置"><a href="#无线网卡配置" class="headerlink" title="无线网卡配置"></a>无线网卡配置</h2><p>本文介绍在Linux 命令行界面中手动配置无线网卡的方法。目前流行的多数发行版都支持用图形界面的<code>network- manager</code>方便地进行配置，而无需使用本文所介绍的原始方法。</p>
<p>下面介绍使用<code>iwconfig</code>和<code>ifconfig</code>等命令在命令行状态下配置无线网络。前题是无线网卡驱动已经正确安装，并被系统正确识别。</p>
<span id="more"></span>
<h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>工作的大体思路如下：</p>
<ol>
<li>用<code>iwconfig</code>开启无线网卡的电源，并查找区域内的无线网络</li>
<li>连接到相应的无线网络</li>
<li>通过<code>ifconfig</code>启用无线网卡，并获取IP（如果使用DHCP的话）</li>
</ol>
<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><ol>
<li>打开无线网卡电源</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0 txpower on</span><br></pre></td></tr></table></figure>
<h4 id="无线网络的信号灯应该亮了。"><a href="#无线网络的信号灯应该亮了。" class="headerlink" title="无线网络的信号灯应该亮了。"></a>无线网络的信号灯应该亮了。</h4><ol start="2">
<li>列出区域内的无线网络<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwlist wlan0 scan</span><br></pre></td></tr></table></figure></li>
<li>假设要连接到网络MyHome（即essid为MyHome的网络），那么输入命令</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0 essid <span class="string">&quot;MyHome&quot;</span> </span><br></pre></td></tr></table></figure>
<p><em>#如果网络是加密的，密码是0123456789，那么就输入命令#</em></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0 essid <span class="string">&quot;MyHome&quot;</span> key <span class="number">0123</span><span class="literal">-4567-89</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>如果正常的话，输入</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0</span><br></pre></td></tr></table></figure>
<h4 id="就可以看到连接正常的各项参数了。"><a href="#就可以看到连接正常的各项参数了。" class="headerlink" title="就可以看到连接正常的各项参数了。"></a>就可以看到连接正常的各项参数了。</h4><ol start="5">
<li>启用无线网卡</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ifconfig wlan0 up</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果是用DHCP获取IP的，那么用dhclient 或dhcpcd获取ip</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dhcpcd wlan0</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dhclient wlan0</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>现在无线网卡应该可以正常使用了。</li>
</ol>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>   如果现在还不能联网。那么点击网络图标。选择链接到隐藏的无线网络。输入找到的网络的名字。<br>      图形化的网络管理程序是<code>System-&gt;Preferences-&gt;Network Connections</code>。打开程序后，点击无线网络项目，点击add增加一个新的无线网络。  给出任意的<code>Connection Name</code>。<code>SSID</code>中输入无限网络的名字。<code>wireless security</code>中选择一种合适的加密类型。key中输入无限网络的密码。 </p>
<p>   其他字段都不修改。 执行后，应该能够链接无限网络。  可以使用<code>iwconfig wlan0</code>命令查看是否正确连接无线网络。</p>
<h6 id="未正确链接无线网络的输出："><a href="#未正确链接无线网络的输出：" class="headerlink" title="未正确链接无线网络的输出："></a>未正确链接无线网络的输出：</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0</span><br><span class="line">wlan0     IEEE <span class="number">802.11</span>abg  ESSID:off/any </span><br><span class="line">          Mode:Managed  Access Point: Not<span class="literal">-Associated</span>   Tx<span class="literal">-Power</span>=<span class="number">0</span> dBm  </span><br><span class="line">          Retry  long limit:<span class="number">7</span>   RTS thr:off   Fragment thr:off</span><br><span class="line">          Power Management:off</span><br></pre></td></tr></table></figure>

<h6 id="正确链接无线网络后的输出："><a href="#正确链接无线网络后的输出：" class="headerlink" title="正确链接无线网络后的输出："></a>正确链接无线网络后的输出：</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iwconfig wlan0</span><br><span class="line">wlan0     IEEE <span class="number">802.11</span>abg  ESSID:<span class="string">&quot;MyHome&quot;</span> </span><br><span class="line">          Mode:Managed  Frequency:<span class="number">2.437</span> GHz  Access Point: <span class="number">00</span>:<span class="number">26</span>:DS:<span class="number">43</span>:<span class="number">1</span>A:A8  </span><br><span class="line">          Bit Rate=<span class="number">54</span> Mb/s   Tx<span class="literal">-Power</span>=<span class="number">0</span> dBm  </span><br><span class="line">          Retry  long limit:<span class="number">7</span>   RTS thr:off   Fragment thr:off</span><br><span class="line">          Power Management:off</span><br><span class="line">          Link Quality=<span class="number">65</span>/<span class="number">70</span>  Signal level=<span class="literal">-45</span> dBm </span><br><span class="line">          Rx invalid nwid:<span class="number">0</span>  Rx invalid crypt:<span class="number">0</span>  Rx invalid frag:<span class="number">0</span></span><br><span class="line">          Tx excessive retries:<span class="number">0</span>  Invalid misc:<span class="number">0</span>   Missed beacon:<span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>无线网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux通过密钥对免密登录</title>
    <url>/2022/09/21/Linux%E9%80%9A%E8%BF%87%E5%AF%86%E9%92%A5%E5%AF%B9%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>首先，说明一下我们要做的是，跳板机服务器的<code>usera</code>用户免密码登录B服务器的<code>userb</code>用户。<br>我们先使用<code>usera</code>登录跳板服务器</p>
<blockquote>
<p>首先生成密钥对如果有则跳过这一步</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>操作演示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[sera@serverA ~]$ ssh-keygen -t rsa  <span class="comment">//使用rsa算法加密</span></span><br><span class="line"><span class="title class_">Generating</span> public/private rsa key pair.</span><br><span class="line"><span class="title class_">Enter</span> file <span class="keyword">in</span> which to save the key (<span class="regexp">/home/u</span>sera/.<span class="property">ssh</span>/id_rsa): <span class="comment">//私钥默认保存路径</span></span><br><span class="line"><span class="title class_">Created</span> directory <span class="string">&#x27;/home/usera/.ssh&#x27;</span>.</span><br><span class="line"><span class="title class_">Enter</span> passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment">//在这里输入密码如果这里输入密码以后登录需要密钥和密码才能登录这里建议直接回车也就是空</span></span><br><span class="line"><span class="title class_">Enter</span> same passphrase <span class="attr">again</span>:</span><br><span class="line"><span class="title class_">Your</span> identification has been saved <span class="keyword">in</span> /home/usera/.<span class="property">ssh</span>/id_rsa.</span><br><span class="line"><span class="title class_">Your</span> public key has been saved <span class="keyword">in</span> /home/usera/.<span class="property">ssh</span>/id_rsa.<span class="property">pub</span>. <span class="comment">//公钥保存路径</span></span><br><span class="line"><span class="title class_">The</span> key fingerprint <span class="attr">is</span>:</span><br><span class="line"><span class="number">39</span>:<span class="attr">f2</span>:<span class="attr">fc</span>:<span class="number">70</span>:<span class="attr">ef</span>:<span class="attr">e9</span>:<span class="attr">bd</span>:<span class="number">05</span>:<span class="number">40</span>:6<span class="attr">e</span>:<span class="number">64</span>:<span class="attr">b0</span>:<span class="number">99</span>:<span class="number">56</span>:6<span class="attr">e</span>:<span class="number">01</span> usera@serverA</span><br><span class="line"><span class="title class_">The</span> key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">| Eo* |</span></span><br><span class="line"><span class="string">| @ . |</span></span><br><span class="line"><span class="string">| = * |</span></span><br><span class="line"><span class="string">| o o . |</span></span><br><span class="line"><span class="string">| . S . |</span></span><br><span class="line"><span class="string">| + . . |</span></span><br><span class="line"><span class="string">| + . .|</span></span><br><span class="line"><span class="string">| + . o . |</span></span><br><span class="line"><span class="string">| .o= o. |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>以下是截图提示</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210216196.png"></p>
<blockquote>
<p>id_rsa是私钥，id_rsa.pub是公钥公钥在服务器私钥在自己手上</p>
</blockquote>
<p>此时会在<code>/home/usera/.ssh</code>目录下生成密钥对我们使用<code>ls</code>查看一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">root@<span class="attr">vultr</span>:~#  ls -la .<span class="property">ssh</span></span><br><span class="line">total <span class="number">16</span></span><br><span class="line">drwx------ <span class="number">2</span> root root <span class="number">4096</span> <span class="title class_">Mar</span> <span class="number">26</span> <span class="number">18</span>:<span class="number">01</span> .</span><br><span class="line">drwx------ <span class="number">5</span> root root <span class="number">4096</span> <span class="title class_">Mar</span> <span class="number">26</span> <span class="number">18</span>:<span class="number">00</span> ..</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">1675</span> <span class="title class_">Mar</span> <span class="number">26</span> <span class="number">18</span>:<span class="number">01</span> id_rsa</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">398</span> <span class="title class_">Mar</span> <span class="number">26</span> <span class="number">18</span>:<span class="number">01</span> id_rsa.<span class="property">pub</span></span><br></pre></td></tr></table></figure>

<p>然后将公钥上传到需要登录的服务器，并以<code>userb</code>用户登录<br>至于上传方式可以用<code>scp</code>以及<code>sz</code>命令这里就介绍了<br>可以参考这篇<a href="https://shagain.club/index.php/archives/111/">文章</a></p>
<blockquote>
<p>上传到用户目录下的.ssh文件夹下<code>authorized_keys</code>这个文件是用来存放公钥内容的我们使用<code>cat</code>把公钥追加到<code>authorized_keys</code>这个文件就好了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat id_rsa.<span class="property">pub</span> &gt;&gt; ~<span class="regexp">/.ssh/</span>authorized_keys    <span class="comment">//cat 公钥路径 &gt;&gt; ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>这样子我们就配置好了<br>另外我们要注意，<code>.ssh</code>目录的权限为<code>700</code>，其下文件<code>authorized_keys</code>和私钥的权限为<code>600</code>。否则会因为权限问题导致无法免密码登录。我们可以看到登陆后会有<code>known_hosts</code>文件生成。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/08/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo域名解析的两种方法</title>
    <url>/2022/08/19/hexo%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要在浏览器里面输入域名到达某个地址。必不可少的一步就是要告诉全世界的电脑，这个域名现在指向这个地方啦。<br>而这一步就是由 dns 服务器来负责的。<br>我们需要做的就是将域名与固定的 ip 地址绑定起来 (A)，或者是与某已有域名绑定起来（CNAME）.</p>
<p>下面我们以阿里云购买的域名为例</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h3><p>首先获取自己 github 的二级域名的 IP 地址，win­dows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：</p>
<span id="more"></span>

<p><img src="https://movejian.github.io/images/20220819/cmd.png"></p>
<p>我的 ip 是 185.199.111.153</p>
<p>下面通过 DNS 域名解析将购买的域名指向 github 的二级域名：user­name.github.io，<br>进入阿里云的管理控制台 - 云解析 DNS，进入域名的解析设置，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现：</p>
<p><img src="https://movejian.github.io/images/20220819/yumi.png"><br>记录值就是自己 github 的二级域名的 IP 地址。</p>
<p>方法二（推荐）<br>直接解析域名的 CNAME 记录到你的 Git 二级域名，不要使用方法一中的 A 记录，因为 ip 地址可能会一段时间之后会改变 (由于网络地址转换协议 NAT)，所以建议记录类型选择 CNAME 进行解析，记录值填的就是 user­name.github.io，比如：</p>
<p><img src="https://movejian.github.io/images/20220819/yumi2.png"></p>
<p>如果你只用 github 的二级域名作为博客的地址，那么线路类型选择默认就可以了。</p>
<h2 id="设置CNAME"><a href="#设置CNAME" class="headerlink" title="设置CNAME"></a>设置CNAME</h2><p>在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如：<br>test­blog.top</p>
<p><img src="https://movejian.github.io/images/20220819/CNAME.png"></p>
<p>在 github 上面，打开 user­name.github.io 项目的（Set­tings）设置，然后在  Pages 选项,点击蓝色的按钮Add a domain 设置里填上购买的域名。比如：</p>
<p><img src="https://movejian.github.io/images/20220819/domain.png"></p>
<blockquote>
<p>现在即可通过原二级域名和新域名访问hexo博客啦。</p>
</blockquote>
]]></content>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>npm安装卸载命令</title>
    <url>/2022/08/23/npm%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="npm安装模块"><a href="#npm安装模块" class="headerlink" title="npm安装模块"></a>npm安装模块</h2><p>利用 npm 安装xxx模块到当前命令行所在目录；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>利用npm安装全局模块xxx；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g xxx</span><br></pre></td></tr></table></figure>

<h2 id="本地安装时将模块写入package-json中："><a href="#本地安装时将模块写入package-json中：" class="headerlink" title="本地安装时将模块写入package.json中："></a>本地安装时将模块写入package.json中：</h2><p>安装但不写入package.json；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx</span><br></pre></td></tr></table></figure>

<p>安装并写入package.json的”dependencies”中；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx –save</span><br></pre></td></tr></table></figure>

<p>安装并写入package.json的”devDependencies”中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx –save-dev</span><br></pre></td></tr></table></figure>

<h2 id="npm-删除模块"><a href="#npm-删除模块" class="headerlink" title="npm 删除模块"></a>npm 删除模块</h2><p>删除xxx模块；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall xxx</span><br></pre></td></tr></table></figure>

<p>删除全局模块xxx；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall -g xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode配置picgo的github的图床</title>
    <url>/2022/08/19/vscode%E9%85%8D%E7%BD%AEpicgo%E7%9A%84github%E7%9A%84%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>vscode+github+picgo 搭建 markdown 图床</p>
<h2 id="一、vscode-配置"><a href="#一、vscode-配置" class="headerlink" title="一、vscode 配置"></a>一、vscode 配置</h2><h3 id="1、安装-Markdown-All-in-One-插件"><a href="#1、安装-Markdown-All-in-One-插件" class="headerlink" title="1、安装 Markdown All in One 插件"></a>1、安装 Markdown All in One 插件</h3><p>Markdown All in One 插件作为 Markdown 编辑器非常好用，既可以预览，对语法的支持也非常好。</p>
<h3 id="2、安装-markdownlint-插件"><a href="#2、安装-markdownlint-插件" class="headerlink" title="2、安装 markdownlint 插件"></a>2、安装 markdownlint 插件</h3><p>这是个功能强大的 Markdown 语法检查器，可以帮助你书写出规范的文档，同时避免书写错误导致文档无法渲染。<br>markdownlint 制定了很多书写规范，如果不按照它的规范编写文章，则会提示很多错误或警告。</p>
<span id="more"></span>

<h3 id="3、安装-picgo-插件"><a href="#3、安装-picgo-插件" class="headerlink" title="3、安装 picgo 插件"></a>3、安装 picgo 插件</h3><p>可以下载 picgo 客户端来使用，但是这里直接在 vscode 中下载 picgo 插件也是可以的，只需要配置一下，配置方法在文章后面。</p>
<h2 id="二、GitHub-配置"><a href="#二、GitHub-配置" class="headerlink" title="二、GitHub 配置"></a>二、GitHub 配置</h2><h3 id="1、创建一个仓库，必须为public"><a href="#1、创建一个仓库，必须为public" class="headerlink" title="1、创建一个仓库，必须为public"></a>1、创建一个仓库，必须为public</h3><p><img src="https://movejian.github.io/images/20220819/picgo1.png"></p>
<h3 id="2、获取-Tokens"><a href="#2、获取-Tokens" class="headerlink" title="2、获取  Tokens"></a>2、获取  Tokens</h3><h4 id="①-进入个人设置页面，依次选择-【Developer-settings】-–-gt-【Personal-access-tokens】，然后点击【Generate-new-token】来生成新的-tokens，此-token是上传时验证身份用的。"><a href="#①-进入个人设置页面，依次选择-【Developer-settings】-–-gt-【Personal-access-tokens】，然后点击【Generate-new-token】来生成新的-tokens，此-token是上传时验证身份用的。" class="headerlink" title="① 进入个人设置页面，依次选择 【Developer settings】 –&gt; 【Personal access tokens】，然后点击【Generate new token】来生成新的 tokens，此 token是上传时验证身份用的。"></a>① 进入个人设置页面，依次选择 【Developer settings】 –&gt; 【Personal access tokens】，然后点击【Generate new token】来生成新的 tokens，此 token是上传时验证身份用的。</h4><p>注意：这个【Developer settings】对新手很不友好,不好找.在设置页面的最下方.</p>
<p><img src="https://movejian.github.io/images/20220819/picgo3.png"></p>
<h4 id="②-添加描述，然后将-repo-选上"><a href="#②-添加描述，然后将-repo-选上" class="headerlink" title="② 添加描述，然后将 repo 选上"></a>② 添加描述，然后将 repo 选上</h4><p><img src="https://movejian.github.io/images/20220819/picgo4.png"></p>
<h4 id="③-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"><a href="#③-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了" class="headerlink" title="③ 将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"></a>③ 将生成的字符串保存，关闭页面后将再也无法看到这个字符串了</h4><p><img src="https://movejian.github.io/images/20220819/picgo5.png"></p>
<h2 id="三、picgo-配置"><a href="#三、picgo-配置" class="headerlink" title="三、picgo 配置"></a>三、picgo 配置</h2><p>打开 vscode 的设置界面，搜索”picgo”定位到 picgo，具体配置如图：</p>
<p><img src="https://movejian.github.io/images/20220819/picgo6.png"></p>
<p>配置picgo</p>
<p><img src="https://movejian.github.io/images/20220819/picgo7.png"></p>
<ol>
<li><h4 id="current-设置为-GitHub"><a href="#current-设置为-GitHub" class="headerlink" title="current 设置为 GitHub"></a>current 设置为 GitHub</h4></li>
<li><h4 id="Branch-是我们仓库的分支，默认为-main"><a href="#Branch-是我们仓库的分支，默认为-main" class="headerlink" title="Branch 是我们仓库的分支，默认为 main"></a>Branch 是我们仓库的分支，默认为 main</h4></li>
<li><h4 id="custom-url-使我们图片上传的连接，有两种方式可以使用"><a href="#custom-url-使我们图片上传的连接，有两种方式可以使用" class="headerlink" title="custom url 使我们图片上传的连接，有两种方式可以使用"></a>custom url 使我们图片上传的连接，有两种方式可以使用</h4><ol>
<li><h5 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h5>使用 GitHub 原生连接，格式为： <a href="https://raw.githubusercontent.com/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]/[%E5%88%86%E6%94%AF%E5%90%8D]">https://raw.githubusercontent.com/[用户名]/[仓库名]/[分支名]</a><br>我的例子：<a href="https://raw.githubusercontent.com/misswenzi/gallery/main">https://raw.githubusercontent.com/misswenzi/gallery/main</a><br>原生方式有一个弊端就是，国内速度比较慢</li>
<li><h5 id="cdn-加速方式"><a href="#cdn-加速方式" class="headerlink" title="cdn 加速方式"></a>cdn 加速方式</h5>格式为：<a href="https://cdn.jsdelivr.net/gh/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@[%E5%88%86%E6%94%AF%E5%90%8D]">https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支名]</a><br>我的例子：<a href="https://cdn.jsdelivr.net/gh/misswenzi/gallery@main">https://cdn.jsdelivr.net/gh/misswenzi/gallery@main</a></li>
</ol>
</li>
<li><h4 id="cdn-加速的优点是国内访问速度比较快"><a href="#cdn-加速的优点是国内访问速度比较快" class="headerlink" title="cdn 加速的优点是国内访问速度比较快"></a>cdn 加速的优点是国内访问速度比较快</h4></li>
<li><h4 id="path-是我们的图片存储在仓库中的路径，比如我的是-blogs-x2F-pictures-x2F-（注意：pictures-后面的-“-x2F-“-要记得加上）Repo-是我们的仓库，比如我的是-misswenzi-x2F-gallery"><a href="#path-是我们的图片存储在仓库中的路径，比如我的是-blogs-x2F-pictures-x2F-（注意：pictures-后面的-“-x2F-“-要记得加上）Repo-是我们的仓库，比如我的是-misswenzi-x2F-gallery" class="headerlink" title="path 是我们的图片存储在仓库中的路径，比如我的是 blogs&#x2F;pictures&#x2F;（注意：pictures 后面的 “&#x2F;“ 要记得加上）Repo 是我们的仓库，比如我的是 misswenzi&#x2F;gallery"></a>path 是我们的图片存储在仓库中的路径，比如我的是 blogs&#x2F;pictures&#x2F;（注意：pictures 后面的 “&#x2F;“ 要记得加上）Repo 是我们的仓库，比如我的是 misswenzi&#x2F;gallery</h4></li>
<li><h4 id="Token：即-GitHub-中获取的-Tokens"><a href="#Token：即-GitHub-中获取的-Tokens" class="headerlink" title="Token：即 GitHub 中获取的 Tokens"></a>Token：即 GitHub 中获取的 Tokens</h4></li>
</ol>
<h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>进入 vscode，新建一个 .md 文件，windows 下 【ctrl+alt+U】从剪贴板粘贴图片，【ctrl+alt+E】打开资源管理器，选择图片，如果上传成功，则搭建成功！</p>
<p><img src="https://movejian.github.io/images/20220819/picgo8.png"></p>
<p>此时，去 GitHub 对应的仓库下查看，可以看到上传成功的图片。</p>
<p>在 vscode 中插入的图片会上传到 GitHub 的仓库中，如果删除了仓库里面的图片，那你的 Markdown 里面的图片链接就会失效。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/blog/images/20220819100154.png" alt="20220819100154"></p>
<p>首先不提好用不好用,反正我这样配置失败了,还请高人指点！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>传奇内挂垃圾物品过滤</title>
    <url>/2022/09/03/%E4%BC%A0%E5%A5%87%E5%86%85%E6%8C%82%E5%9E%83%E5%9C%BE%E7%89%A9%E5%93%81%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<p> 传奇内挂过滤垃圾。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209031601159.png" alt="image-20220903160139387"></p>
<p>先打开传奇目录 <code>D:\传奇私服\Config </code>   修改DAT档案文件，把下面内容复制粘贴进去保存即可：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">金创药(小量),药品类,0,0,0,0</span><br><span class="line">魔法药(小量),药品类,0,0,0,0</span><br><span class="line">肉,其它类,0,0,0,0</span><br><span class="line">布衣(男),服装类,0,0,0,0</span><br><span class="line">布衣(女),服装类,0,0,0,0</span><br><span class="line">木剑,武器类,0,0,0,0</span><br><span class="line">铁剑,武器类,0,0,0,0</span><br><span class="line">青铜剑,武器类,0,0,0,0</span><br><span class="line">轻型盔甲(男),服装类,0,0,0,0</span><br><span class="line">轻型盔甲(女),服装类,0,0,0,0</span><br><span class="line">凝霜,武器类,0,0,0,0</span><br><span class="line">短剑,武器类,0,0,0,0</span><br><span class="line">青铜斧,武器类,0,0,0,0</span><br><span class="line">重盔甲(女),服装类,0,0,0,0</span><br><span class="line">魔法长袍(女),服装类,0,0,0,0</span><br><span class="line">灵魂战衣(女),服装类,0,0,0,0</span><br><span class="line">重盔甲(男),服装类,0,0,0,0</span><br><span class="line">魔法长袍(男),服装类,0,0,0,0</span><br><span class="line">灵魂战衣(男),服装类,0,0,0,0</span><br><span class="line">海魂,武器类,0,0,0,0</span><br><span class="line">修罗,武器类,0,0,0,0</span><br><span class="line">破魂,武器类,0,0,0,0</span><br><span class="line">斩马刀,武器类,0,0,0,0</span><br><span class="line">青铜头盔,首饰类,0,0,0,0</span><br><span class="line">金项链,首饰类,0,0,0,0</span><br><span class="line">铁手镯,首饰类,0,0,0,0</span><br><span class="line">灰色药粉(中量),药品类,0,0,0,0</span><br><span class="line">黄色药粉(中量),药品类,0,0,0,0</span><br><span class="line">八荒,武器类,0,0,0,0</span><br><span class="line">玻璃戒指,首饰类,0,0,0,0</span><br><span class="line">牛角戒指,首饰类,0,0,0,0</span><br><span class="line">蓝色水晶戒指,首饰类,0,0,0,0</span><br><span class="line">黑檀项链,首饰类,0,0,0,0</span><br><span class="line">黄色水晶项链,首饰类,0,0,0,0</span><br><span class="line">黑色水晶项链,首饰类,0,0,0,0</span><br><span class="line">半月,武器类,0,0,0,0</span><br><span class="line">皮制手套,首饰类,0,0,0,0</span><br><span class="line">钢手镯,首饰类,0,0,0,0</span><br><span class="line">生铁戒指,首饰类,0,0,0,0</span><br><span class="line">金戒指,首饰类,0,0,0,0</span><br><span class="line">灯笼项链,首饰类,1,1,1,0</span><br><span class="line">白色虎齿项链,首饰类,1,1,1,0</span><br><span class="line">魅力戒指,首饰类,0,0,0,0</span><br><span class="line">道德戒指,首饰类,0,0,0,0</span><br><span class="line">白金项链,首饰类,0,0,0,0</span><br><span class="line">降妖除魔戒指,首饰类,0,0,0,0</span><br><span class="line">偃月,武器类,0,0,0,0</span><br><span class="line">降魔,武器类,0,0,0,0</span><br><span class="line">小手镯,首饰类,0,0,0,0</span><br><span class="line">银手镯,首饰类,0,0,0,0</span><br><span class="line">大手镯,首饰类,0,0,0,0</span><br><span class="line">金创药(中量),药品类,0,0,0,0</span><br><span class="line">魔法药(中量),药品类,0,0,0,0</span><br><span class="line">黑色水晶戒指,首饰类,0,0,0,0</span><br><span class="line">魔鬼项链,首饰类,0,0,0,0</span><br><span class="line">珊瑚戒指,首饰类,0,0,0,0</span><br><span class="line">蓝翡翠项链,首饰类,0,0,0,0</span><br><span class="line">蛇眼戒指,首饰类,0,0,0,0</span><br><span class="line">琥珀项链,首饰类,0,0,0,0</span><br><span class="line">放大镜,首饰类,0,0,0,0</span><br><span class="line">珍珠戒指,首饰类,0,0,0,0</span><br><span class="line">竹笛,首饰类,0,0,0,0</span><br><span class="line">骷髅戒指,首饰类,0,0,0,0</span><br><span class="line">死神手套,首饰类,0,0,0,0</span><br><span class="line">骷髅头盔,首饰类,0,0,0,0</span><br><span class="line">魔法手镯,首饰类,0,0,0,0</span><br><span class="line">金手镯,首饰类,0,0,0,0</span><br><span class="line">道士头盔,首饰类,0,0,0,0</span><br><span class="line">凤凰明珠,首饰类,0,0,0,0</span><br><span class="line">道士手镯,首饰类,0,0,0,0</span><br><span class="line">黑檀手镯,首饰类,0,0,0,0</span><br><span class="line">铁矿,其它类,0,0,0,0</span><br><span class="line">黑铁矿,其它类,0,0,0,0</span><br><span class="line">困魔咒,其它类,0,0,0,0</span><br><span class="line">召唤骷髅,其它类,0,0,0,0</span><br><span class="line">地狱雷光,其它类,0,0,0,0</span><br><span class="line">半月弯刀,其它类,0,0,0,0</span><br><span class="line">太阳水,药品类,0,1,0,0</span><br><span class="line">强效金创药,药品类,0,1,0,0</span><br><span class="line">强效魔法药,药品类,0,1,0,0</span><br><span class="line">野蛮冲撞,其它类,0,0,0,0</span><br><span class="line">群体治疗术,其它类,0,0,0,0</span><br><span class="line">圣言术,其它类,0,0,0,0</span><br><span class="line">强效太阳水,药品类,0,1,0,0</span><br><span class="line">魔力手镯,首饰类,0,0,0,0</span><br><span class="line">攻击力药水,其它类,0,0,0,0</span><br><span class="line">道术力药水,其它类,0,0,0,0</span><br><span class="line">疾风药水,其它类,0,0,0,0</span><br><span class="line">体力强化水,其它类,0,0,0,0</span><br><span class="line">魔力强化水,其它类,0,0,0,0</span><br><span class="line">战神盔甲(男),服装类,0,0,0,0</span><br><span class="line">战神盔甲(女),服装类,0,0,0,0</span><br><span class="line">幽灵战衣(男),服装类,0,0,0,0</span><br><span class="line">幽灵战衣(女),服装类,0,0,0,0</span><br><span class="line">恶魔长袍(男),服装类,0,0,0,0</span><br><span class="line">恶魔长袍(女),服装类,0,0,0,0</span><br><span class="line">中型盔甲(男),服装类,0,0,0,0</span><br><span class="line">灯笼项链②,首饰类,1,1,1,0</span><br><span class="line">灯笼项链[残],首饰类,1,1,1,0</span><br><span class="line">白色虎齿项链[残],首饰类,1,1,1,0</span><br><span class="line">白色虎齿项链②,首饰类,1,1,1,0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>游戏</category>
        <category>传奇</category>
      </categories>
      <tags>
        <tag>传奇</tag>
        <tag>外挂</tag>
      </tags>
  </entry>
  <entry>
    <title>使用HEXO-GIT-BACKUP插件备份博客源文件</title>
    <url>/2022/08/21/%E4%BD%BF%E7%94%A8HEXO-GIT-BACKUP%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>在搭建好hexo博客之后也要给自己的博客进行备份，文章丢失可是很麻烦的一件事情。我的博客的数据都是直接保存在cloudstudio，用的时候总是会感觉有点问题，生怕自己哪天不小心把工作空间给删除了，那就蛮麻烦了。所以我采用了 <a href="https://github.com/coneycode/hexo-git-backup">hexo-git-backup</a> 这个工具进行备份。</p>
<h2 id="查看HEXO版本"><a href="#查看HEXO版本" class="headerlink" title="查看HEXO版本"></a>查看HEXO版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>第一行的hexo：xxx既为版本</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208211933353.png" alt="查看hexo版本"></p>
<p>如图，我的版本是6.2.0</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果你的版本是2.x.x使用这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-git-backup@0.0.91 --save</span><br></pre></td></tr></table></figure>

<p>如果你的版本是3.x.x则使用这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>

<p>这里我使用的是第二条命令，因为我的hexo版本为6.2.0</p>
<h2 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h2><p>来到你的github仓库目录或者是coding的仓库目录，选择新建分支，因为我是双线部署，所以两个都要创建分支，我创建的分支名都为backup</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208211919299.png" alt="查看所有分支和管理"></p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208211921232.png" alt="新建分支"></p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208211924488.png" alt="给分支取个名称"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开博客配置文件_config.yml</p>
<p>在最下方添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-git-backup 插件，用来备份的</span><br><span class="line">backup:</span><br><span class="line">    type: git</span><br><span class="line">    repository:</span><br><span class="line">       github: git@github.com:xxx/xxx.git,branchName</span><br><span class="line">       coding: git@github.com:xxx/xxx.git,branchName</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>branchName为分支名（我的分支名称是blogbak），要和前面的仓库地址用英文逗号隔开。</p>
<p>“coding: “是gitlag的库。</p>
<p>这里就差不多配置完成了</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo backup </span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo b</span><br></pre></td></tr></table></figure>

<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>如果你只是想备份主题目录，只需要添加theme属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backup:</span><br><span class="line">    type: git</span><br><span class="line">    theme: coney,landscape,xxx</span><br><span class="line">    repository:</span><br><span class="line">       github: git@github.com:xxx/xxx.git,branchName</span><br><span class="line">       gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure>

<p>如果你想自定义提交的message信息，那么只需要添加message属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backup:</span><br><span class="line">    type: git</span><br><span class="line">    message: update xxx</span><br><span class="line">    repository:</span><br><span class="line">       github: git@github.com:xxx/xxx.git,branchName</span><br><span class="line">       gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure>

<p>插件地址</p>
<p><a href="https://github.com/coneycode/hexo-git-backup">hexo-git-backup</a></p>
<h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><p>记得一定要做好备份，千万不要轻易重装系统，欲哭无泪！</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>十年之约，一个人的寂寞，一群人的狂欢</title>
    <url>/2022/08/21/%E5%8D%81%E5%B9%B4%E4%B9%8B%E7%BA%A6%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%AF%82%E5%AF%9E%EF%BC%8C%E4%B8%80%E7%BE%A4%E4%BA%BA%E7%9A%84%E7%8B%82%E6%AC%A2/</url>
    <content><![CDATA[<p>​       在网络逐步转向手机端的今天，web博客网站似乎已经失去了活力，高昂的服务器费用，还需要技术基础以搭建起网站，忙前忙后设计维护着自己的网站，远不如朋友圈一样说发就发，但真相真的如此吗？我原本也这样理解，直到我发现了这样一个组织-十年之约。</p>
<p>​       <strong>十年之约</strong>是由“十年之约”项目组维护的非营利性、自愿加入的博客活动。加入“十 年之约”可锻炼您的写作能力，进而提升您的思考、观察、记录、分享等能力，是 一项非常有意义的活动。“十年之约”的宗旨是：我们的博客十年不关闭或者更久， 并保持更新和活力。</p>
<p><img src="https://movejian.github.io/images/20220821/1.png"></p>
<span id="more"></span>
<p>​      这是十年之约的官方网站，页面设计很简约，但信息量并不少，经过简单的浏览，我大致了解到”十年之约”所约定的内容–“十年之约，即从加入这个活动起，我们的博客十年不关闭，保持更新和活力！”</p>
<p><img src="https://movejian.github.io/images/20220821/2.png"></p>
<p>​       这是十年之约的规则，不多， 守法 平等 互访 互敬 互助 活力 真诚。</p>
<img src="https://movejian.github.io/images/20220821/4.jpeg" style="zoom:25%;" />

<p>​      想来，我的博龄也有两年多了，从最初的天涯、新浪、到自己搭建<a href="https://www.zblogcn.com/"><strong>ZBlog</strong></a>和使用VPS在<strong>Linux</strong>下的<strong>Centos</strong>利用<a href="https://bt.cn/"><strong>宝塔</strong></a>搭建<a href="https://typecho.org/"><strong>Typecho</strong></a>，从之前的纯技术文章，到现在加入生活琐事杂文，写博客给了我不少寄托，可以毫不夸张的说，要不是写博客，自学php我是坚持不下来的，写博客能给我一种反馈，带来成就感，自己提升的同时，也可以帮助他人，自己的文章得到了他人的认可，甚至影响到了别人，让别人也像我这样去帮助别人，可能这就是我坚持下去的意义吧。</p>
<p>​      有人说，一个个人博客能坚持下去唯一的理由就是盈利，确实，服务器的价格、时间、精力，要想一直坚持下去，很难，所在之后的博客放弃了VPS，虽然目前使用的是<strong>GitHub</strong>，尽可能在不影响阅读的情况下少投放AD，不知道是否会一直保持更新，但我至少现在在坚持，现在在保持更新！</p>
<ul>
<li>任意点开一个成员网站，多以技术文章为主，确实体现了认真性。同时在这里，我看到了技术博主的希望。</li>
</ul>
<p> 十年后，希望变成自己想成为的样子，十年后，望可通过博客回首过往，十年后相遇，再来共叙那年记忆！到来年，暮然回首间，流年清浅，岁月安好！</p>
<p>​      人生能有多少个十年，身边除了家人，又有多少人能陪伴你十年，一辈子很短，能坚持的事不多。我一直觉得，人活下去的动力就是期待，期待明天，期待未来，期待下一个十年，期待以后的生活。上一个十年就这样过去了，下一个十年会是怎样，我很想知道，那就记录下来吧！</p>
<ul>
<li>许个约定，就十年，听起来也很浪漫！下一个十年，我在未来等你！</li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用区块链技术解决信任问题 Fabric 架构深度解读</title>
    <url>/2022/09/21/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E4%BF%A1%E4%BB%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>阿里妹导读：区块链技术，随着比特币的兴起而为大家所知。但是具体到技术本身，大家相对熟悉的几个词可能是“数据不可篡改”、“公开链”、“分布式数据”、“共识机制”等。</p>
<p>这篇文章将抛砖引玉，通过深度解读Hyperledger Project旗下的Fabric，介绍区块链适合的应用场景，如何从技术上去解决实际业务中的问题，希望能和大家一起探讨、学习。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Hyperledger Project 由Linux基金会创办于2015年10月，是一个开源的区块链研发孵化项目，致力于提供可协同开发以区块链为底层的分布式账本。旗下的Fabric项目目标为打造一个提供分布式账本解决方案的平台。</p>
<span id="more"></span>
<p><strong>业务上所期望解决的问题——信用问题</strong></p>
<p>首先从比特币说起，大家对比特币算力证明（POW）的名词应该不陌生，先不说其耗费大量的资源，从共识机制上来看，拥有超过50%的算力即可掌控整个比特币，无论从技术还是业务的角度都是一个风险极高的机制，但神奇的金融圈没有人会去触碰这样的底线，一旦有人拥有超过50%的算力，比特币可能就玩不下去了：）</p>
<p>那么实际的业务场景中的需求应该是怎样的呢？比如说，银行结算清算系统，传统的银行交易系统中，如果出现跨行交易，那么交易数据便需要一个清算系统进行定时对账确保双方的交易数据是同步无误的，那么就可能导致跨行转账需要T+1的时长，而主要的原因是因为双方的系统及数据相互独立，数据互不“信任”，所以需要一个清算系统去验证交易数据，而区块链可以说是为了解决这种“信任”问题而产生的技术，在双方进行交易的同时对数据进行了认证，那么便无需交易后再进行清算而达到实时转账等功能。下面来说为了解决“信用”问题，技术上需要哪些手段去满足。</p>
<p><strong>技术上需要哪些特性去达到“数据可信任”</strong></p>
<p>以上面提出的清算系统为例，可能有人提出，双方使用同一个分布式数据库不就可以达到实时的数据同步了嘛。确实，区块链其中一个特性便是分布式，但是和传统的分布式数据库区别在哪呢？在回归到业务中，如果双方银行进行交易的时候，使用这样一个分布式数据库，难道不担心对方偷偷地把数据改了吗？如果你说有日志可以追述得到修改记录，首先日志也是容易被修改的，且日志也无法挽回动不动可能就上百万千万甚至过亿的金额损失，所以说传统的分布式数据库对于企业之间来说是”不可信的“，那么便要求区块链需要达到数据不可篡改、用户有身份认证、交易可追述、交易有权重等一系列的特性。</p>
<p><strong>剖析技术原理</strong></p>
<p>上面说到区块链的各种特性，从功能上来说这些特性有些是相辅相成。那么应当如何去实现这些功能呢，接下来结合Fabric的一些具体实现来一一阐述。</p>
<p><strong>存储数据结构</strong></p>
<p>要达到数据不可篡改首先从数据结构上来看，也是区块链之所以称之为区块链的原因。如下图所示，每个存储单元包含上一存储单元的hash值（图中hash值的对应关系不完全精确，仅示意用）以及自身存储的交易数据块，可以从表象来看就像把所有数据块连接在一起，称之为“区块链”，形成链状可追述的交易记录。这种链状结构的数据称之为账本数据，保存着所有交易的记录，此外还有一个“世界状态”，其实质为Key-Value数据库，维护着交易数据的最终状态，便于查询等操作运算，并且每个数据都有其对应的版本号。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210008862.jpeg" alt="img"></p>
<p><strong>Fabric主要模块</strong></p>
<p>总体来说，市面上各种区块链的实现方案都是基于这种数据结构，而仅靠数据结构并不能保证数据不可篡改，还有一个非常重要的因素，便是共识机制，一个好的共识机制才是保障整个业务运转的根本，相当于双方签订的合同或者协议，只有双方都遵守条约才能合作将业务展开进行。例如常见的POW，POS，PBFT等都属于共识机制，而其原理或者弊端这里不做赘述，主要来详细讲解Fabric应用的设计方案及其原理，此前先解释下一些特定名词的概念。</p>
<p>首先说”智能合约“的概念。在传统中心化的系统中，例如支付宝用户A给B转账100元，那么假设起始A有100元B有0元，那么在支付宝系统内调用转账的函数可能是这样的一个流程，调用transfer(A,B,100)，而函数内可能会去读取用户A和B的账户余额，那么我们可以表达成input(A,B,100),read(A:100,B:0),write(A:0,B:100)，那么这个仅是在支付宝的系统内执行了便完成了，那如何形成一个合约呢？</p>
<p>就如A、B在签订一份合同，双方都要对合同进行签名认可，在程序中就等于，用户A在其本地执行transfer(A,B,100)得出input(A,B,100),read(A:100,B:0),write(A:0,B:100)并对其签名认证，用户B在其本地执行transfer(A,B,100)得出input(A,B,100),read(A:100,B:0),write(A:0,B:100)并对其签名认证，然后双方将结果发给对方，然后判断对方结果是否一致并对其签名进行校验无误后便认为合约达成将结果写入本地。通俗来说就是将一段核心代码抽出来，所有参与方都去执行该代码并对其结果进行签名认证比对，便称之为执行智能合约，而其中共有的代码便是“合约”。</p>
<p>再说”背书策略“的概念。那么根据上面所言的共有代码在交易中是不是所有用户都要执行呢？比如说A、B用户转账，那么C、D用户显然就不需要规定其参与执行职能合约了，那么背书策略便是规定智能合约的结果需要哪些成员的签名背书才算交易成功。</p>
<p><strong>在Fabric的交易流程中，主要有几个关键节点参与，包括Peer节点、Orderer节点、CA节点及client端。</strong></p>
<ul>
<li>Peer节点</li>
</ul>
<p>该节点是参与交易的主体，可以说是代表每个参与到链上的成员，他负责储存完整的账本数据即区块链数据，负责共识环节中的执行智能合约，其中所有的Peer节点都维护完整的账本数据称之为Committer，而根据具体的业务划分背书策略时决定哪些Peer。</p>
<ul>
<li>Orderer节点</li>
</ul>
<p>该节点负责收集交易请求进行排序并打包生产新的区块，主体功能便是对交易排序从而保证各Peer节点上的数据一致性，也包含了ACL进行访问控制。</p>
<ul>
<li>CA节点</li>
</ul>
<p>该节点负责对加入链内的所有节点进行授权认证，包括上层的client端，每一个节点都有其颁发的证书用于交易流程中的身份识别。</p>
<ul>
<li>client</li>
</ul>
<p>Fabric对于client端提供了SDK让开发人员可以更容易地对接到区块链内的交易环节，交易的发起便是通过SDK进行。</p>
<p><strong>供应链金融中的应用</strong></p>
<p>以上简单的阐述了各模块的功能，当然实际当中包含更多服务支持的功能，那么这里在套进供应链金融来举例，更好地理解各节点的意义。</p>
<p>一个简单的供应链模型，一个核心企业向其供应商进行采购1000w物资，按照赊销合同在收到物资后半年进行结账，那么半年的账期供应商资金无法周转开便拿着核心企业开具的银行承兑汇票进行抵押融资，那么银行审核通过后将票据95%的金额马上转给了供应商，半年账期到后，核心企业便直接将货款转给银行，这样就形成了一次供应链的融资交易了。</p>
<p>在实际的业务当中大部分都是在线下进行操作的，耗费众多的人力及时间，那如何将这样的业务转成线上电子化呢？有人或许说银行提供这样的平台服务不就好了嘛，那假设这个平台不仅仅是这一家银行参与呢，若所有的银行或者企业都可以在同一个平台进行，那么交由某一个银行提供服务就显得不合适了。好，那么我们用Fabric来实现这样一个系统我们看看在部署上是怎样分布的呢。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210009716.jpeg" alt="img"></p>
<p>上面是理想下的模型，当然在实际当中这样的部署方案也可能不成立，比如供应商并不一定有能力在其内部接入服务器等。我们仍然以此为例说明节点的意义，图中每个参与方都在本地部署Peer节点以及接入业务系统client端，那么每个Peer节点都保持了所有交易的数据，那么在查数据的时候仅在本地便可完成，当然也可以去查他人的Peer节点比对数据，而中心的CA节点负责给每一个节点包括client端颁发证书让其在交易流程中可以互相认证从而防止外部恶意接入查看数据或者参与交易，而Orderer节点与所有的Peer节点相连接获取交易结果进行排序控制，那么这里涉及到了整体的交易流程，引用官方的示例图来解释。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202209210009452.jpeg" alt="img"></p>
<p>来描述一下上图的交易流程，首先由client发起一个交易请求，而上图中的背书策略要求Peer1、Peer2及Peer3参与交易，所以client将请求分别发给Peer1、Peer2和Peer3，然后三个Peer接收到交易请求后执行对应的智能合约并对结果进行签名然后分别将输出结果返回给client，client收到所有执行结果后打包一并发送到Orderer，Orderer将接收到的该次交易在交易池里进行排序并组合打包生成一个新的区块，Orderer将新的区块发送给所有的Peer节点，每个Peer节点接收到新区块后，对其中的每一笔交易结果的签名进行验证是否符合背书策略，以及比对读写集合（Read-Write Set，在下面的章节中解释）与本地的版本是否相同，如满足所有条件则将新的区块写入本地账本内完成交易。</p>
<p>以上是相对粗略的描述了交易流程，而实际当中还有很多细节的处理。除此外可能有人会问，共识节点去哪了？为什么有Orderer这样的中心节点？如果再细细思考一下，你会发现共识机制已经融合在整个交易流程中了，这也是这个设计优越的所在，我们来分析一下，假设Orderer节点是恶意节点，是否能控制交易生成”假账“呢？那么再来看一下Orderer的功能，接收交易数据进行排序并打包成块，假设Orderer要造假数据，那么他需要绕过的是每个Peer节点将数据写入前进行的背书策略的校验，那么数据里就必须包含背书策略里要求的节点签名，而Orderer是没有办法获取到各Peer节点的私钥也就没办法生成对应的签名，由此Orderer是没办法控制交易链造假的，可以说Orderer是一个工具服务并不参与到任何业务流程内，其关心的只是服务的稳定性，如果需要数据对Orderer节点保密，目前需要自行实现数据加密。正因为其背书策略的设定，可以精确地满足的具体的业务场景需求不会受到任何形式的恶意节点入侵，这也是区别于POW或者拜占庭容错等，他们在一定条件后是可能被恶意节点所操控的。</p>
<p><strong>核心基础服务</strong></p>
<p>对Fabric的主体模块及流程有一定认识后，我们在继续深究里面的细节功能，为了让整个框架能运作起来当然需要用到更多的技术手段，这里主要讲几个相对核心的功能点。</p>
<ul>
<li>Gossip Protocol</li>
</ul>
<p>回顾上述的交易流程图中，Orderer将交易数据排序打包后分发给各个Peer节点，若假设有成百上千甚至更多的Peer节点都由Orderer节点进行分发那么首先单点的压力是否能承受，其次如果出现失败的情况又该如何同步等问题。在Fabric的实现当中，采用的是让Peer节点之间相互同步而非Orderer节点来分发消息，每个Peer节点都会维护其他Peer节点的信息，随机的与部分其他Peer节点进行通信互换区块信息，传输时利用Peer-to-Peer的技术去加快数据的传输，而Orderer节点仅是将打包好的区块发送至特定的Leader Peer（可手动指定也可由Orderer自行选取），然后Peer节点之间在通过Gossip协议相互交换数据达到最终一致性。</p>
<ul>
<li>Eventhub</li>
</ul>
<p>那么根据上面描述的Gossip协议，可见每个Peer节点写入区块的时间可能是不一致的，那么client端进行业务逻辑判断（如事务逻辑）如何获知特定交易数据是否已经写入Peer节点内呢？实际上每个Peer都会和client端保持一个Eventhub的连接，在Peer节点完成交易后，如将区块写入账本后便会发送消息通知各个client，但是也要注意，回调总是不可信的，存在消息丢失的可能性，Fabric也并没有保证消息的最终到达。</p>
<ul>
<li>Read-Write Set</li>
</ul>
<p>在Peer节点将一个区块写入账本前，如上所述会进行背书策略的校验，以防止恶意节点的入侵，达到有权重划分，可实名制交易的联盟链。除去验证各节点签名验证，当然还要比对个节点输出的结果是否一致，那如何去衡量结果是否一致呢？这里提出了读写集合的概念，一段程序我们化做为IO，如果使用相同Input得出一致的Output，那么我们便可以认同在这一特定情况下函数性质是相同的。在这里我们并不关心Input，只要写入&#x2F;修改的数据一致便可认为达成了共识，所以Write Set是用于保存最终需要写入&#x2F;修改的数据集，这个是用来比对各节点的结果集是否一致，而Read Set中存着各节点执行合约中读取了哪些数据，并会把这个数据的当前版本记录在Read Set中，在Peer节点写入区块前也会校验Read Set中读取的数据版本是否和当前数据环境中的版本一致，以防止交易并发带来的错乱。</p>
<p><strong>认证体系</strong></p>
<p>刚接触区块链的同学可能会有一个概念，区块链应该保证公平公正公开，所以形成了“公有链”的一个概念，例如比特币，全员可参与，对所有人透明。但是区块链并不仅局限于“公有链”，对于大多数业务场景来说，应该属于“联盟链”，即由特定成员参与、有权重分配的业务，例如银行间的对账环节，A、B、C银行互相的交易中，A、B银行间的交易当然不愿意透露给C银行，而A、B、C银行的所有交易或许都要上报给央行，可见此处“公有链”是不可取的。那如何去保证公平公正公开呢？首先代码必须对成员开源，所有服务可由自身搭建，利益相关成员共同审核“智能合约”，全员共识的背书策略，相互授权或由可信第三方认证中心授权。那么最基础的一道认证体系便显得尤为重要了，我们在来看看Fabric是如何去实现他的认证体系的。</p>
<p>首先有几个概念需要明确，Fabric的CA认证中心是基于PKI体系打造的，相关资料可参考如下。</p>
<ul>
<li>PKI(Public Key Infrastructure)</li>
<li>X.509 证书</li>
</ul>
<p><strong>Membership Service Providers(MSP)</strong></p>
<p>在划分成员结构的时候Fabric用MSP来定义一个成员，在最佳实例推荐中，一个企业或者机构可以是一个单独的MSP，例如上述说到的供应链的案例，由例图来说明，核心企业便是一个MSP，银行和供应商各代表一个MSP，那么在一个MSP下可以有多个Peer节点，而不同的授权便有不同的功能，MSP具体应用场景主要如下。</p>
<ul>
<li><p>在部署智能合约或者初始化时需要拥有对应CA赋权的证书才可执行（默认为PeerAdmin用户）。</p>
</li>
<li><p>为新节点或用户注册证书时，需要CA对该操作证书赋予权限（一般为Admin用户）。</p>
</li>
<li><p>在背书策略中可通过MSP来代表背书成员，可设定单个Peer节点代表其MSP达成协议（也可以要求全部Peer节点通过才达成协议）。</p>
</li>
<li><p>在跨MSP间的Peer节点通信，先通过各MSP内指定的Anchor Peer收集MSP内的Peer列表，然后通过各MSP下的Anchor Peer交互其Peer列表，将其他MSP下的Peer列表同步到内部Peer后，便通过Gossip协议Peer节点间随机通信。</p>
</li>
<li><p>每个MSP都有自己独立的CA节点，为其提供所有的证书需求，各MSP共享其CA节点的ROOT证书达到互相认证。</p>
</li>
<li><p>匿名交易。在一笔交易中，包含着每一个参与背书的用户证书，这可以认为是公开实名制的交易，所有链内成员都可以看见每一笔交易是由谁参与的，但是如果我们希望匿名交易该如何实现呢？在Fabric 0.6版本内有Ecert和Tcert的概念，Ecert即为用户的证书，而Tcert则是用于匿名交易，用户可以通过向CA申请一批Tcert用于交易，而该Tcert不包含用户的信息，当需要验证查验信息时可通过CA来认证该用户的身份。（此功能在1.0版本尚未实现）</p>
</li>
<li><p>Revoke，废除证书。在PKI体系中，其最大的优势便是Off line的，即在证书颁发后，不需要CA节点的存在也可以在本地进行认证，而遇到很大的问题是类似于废除证书时如果希望能即是将废除证书的消息通知到各个节点，目前的做法是需要CA节点保持在线并与各节点保持通信。（获取Tcert也需要CA节点在线）</p>
</li>
</ul>
<p>在每个区块链中其相关的配置信息也包含了MSP的划分，阐述相对复杂这里便不描述，有兴趣可以参考官方文档 ：）</p>
<p><strong>难点及待解决的问题</strong></p>
<p>上述篇幅主要是给读者对Fabric的整体框架有基本的认识，仍有许多细微的问题无法一一讨论。当然，在区块链尚未大规模能应用于市场下其技术也是不完善的，在Fabric中也有许多需要解决的难点问题。</p>
<p>在官方推荐的实践当中，划分数据的隔离是通过账本的粒度进行隔离，不关联的交易便在不同的账本中了，但是实际业务当中，总有需要在单账本内进行数据隔离的场景，早前已经看到有相关的设计文档出稿了，不过距离正式发布该功能就不确定合适能完成了，目前只能自行在业务逻辑中对数据进行加密隔离。</p>
<p>当两个数据通过账本隔离后需要交互的场景目前来看是比较难实现的，及跨账本调用，首要解决的问题便是认证模型如何去进行融合。</p>
<p>目前想要接入区块链的成本仍然是很高的，即便Fabric项目大部分功能都无法通过可视化的配置，需要了解更多的底层细节才能正确搭建环境及配置。</p>
<p><strong>引用</strong></p>
<ul>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/release/">https://hyperledger-fabric.readthedocs.io/en/release/</a></li>
<li><a href="https://github.com/hyperledger/fabric">https://github.com/hyperledger/fabric</a></li>
<li><a href="https://www.ibm.com/blockchain/hyperledger.html">https://www.ibm.com/blockchain/hyperledger.html</a></li>
</ul>
<p> 来源：阿里技术</p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>将Windows打印机变成网络打印机</title>
    <url>/2022/09/11/%E5%B0%86Windows%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8F%98%E6%88%90%E7%BD%91%E7%BB%9C%E6%89%93%E5%8D%B0%E6%9C%BA/</url>
    <content><![CDATA[<p>大家都知道Windows的打印共享一直属于玄学，2000&#x2F;XP&#x2F;2003（NT 5.x）及以前的时代基本还算正常，经过简单的设置总能搞定，自从Vista开始的NT 6.x，尤其到了win10&#x2F;win11时代，Windows的打印共享基本上就变成了玄学，姑且不说很难搞定，就算搞定了，一个补丁也可能把它搞残废。另外，Windows的共享服务一直存在各种安全漏洞，曾经一度被勒索病毒利用，尤其是win7（不能打补丁那种），为了安全，我一般都禁用server服务。</p>
<span id="more"></span>
<p>但自带网络接口的打印机从来没有这么复杂，指定IP（端口基本上就是基于raw的9100），安装驱动即可搞定，完全跳过了复杂的samba协议，直接使用TCP&#x2F;IP。如同在Windows下通过http或者ftp共享文件，完全不需要考虑Windows那复杂的共享机制。</p>
<p>但并不是所有的打印机都带网络接口，虽然现在可以买一个便宜的可以刷固件的路由器（比如坛子里15块收的优酷路由宝刷Padavan或者OpenWRT）当打印服务器使用，但毕竟硬件都不是现成的，而且，投入再小也得投入不是。</p>
<p>那能不能将Windows直接变成类似的打印服务器呢？答案是：Raw Print Server。这是一个开源的命令行程序，官方网站：<a href="https://sourceforge.net/projects/rawprintserver/files/RawPrintServer/">https://sourceforge.net/projects/rawprintserver/files/RawPrintServer/</a> 。注意，下载1.0版本， 不要下载那个beta版。<a href="https://www.253874.net/attachment?id=72646">RawPrintServer100.zip</a> 也附上了1.0版本的可执行程序及程序源码。</p>
<p>Github项目链接：<a href="https://github.com/miso-lims/rawprintserver">https://github.com/miso-lims/rawprintserver</a> (这程序从2006年就停止开发了）。</p>
<p><strong>基本操作流程：</strong></p>
<p>1、在作为打印服务器的Windows上安装好打印机，以HP LaserJet P1008为例，装好打印机时，最好给打印机改一个简短的名字，例如叫：HP1008。</p>
<p>2、将rawprintserver.exe复制到Windows的system32目录。</p>
<p>3、管理员cmd模式下执行：rawprintserver.exe install “HP1008”。注意，这里的打印机名称一定要跟你Windows控制面板中显示的打印机名称一样。该程序会安装一个rawprintserver服务，如果你在上一步操作中没有将该文件复制到system32目录，那就需要修改下对应服务注册表项中的ImagePath项，将该程序的全路径写入，否则服务启动不了。</p>
<p>4、在打印客户端按添加网络打印机的流程（自动搜索肯定是搜不到的，所以需要手工操作），指定IP地址，默认raw:9100，然后手工指定打印机驱动安装即可。</p>
<p>5、搞定！</p>
<p>6、软件运行的日志强行锁死在c:\PrintServer.log，如果出现什么错误，可以查看该日志。</p>
<p>我试过在win10下安装rawprintserver，win7_x86和win11都可以正常连接并使用。<br><em>相关地址</em><br><a href="https://sourceforge.net/projects/rawprintserver/files/RawPrintServer/"><em>https://sourceforge.net/projects/rawprintserver/files/RawPrintServer/</em></a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>愿你编码半生，归来仍是少年</title>
    <url>/2019/10/21/%E6%84%BF%E4%BD%A0%E7%BC%96%E7%A0%81%E5%8D%8A%E7%94%9F%EF%BC%8C%E5%BD%92%E6%9D%A5%E4%BB%8D%E6%98%AF%E5%B0%91%E5%B9%B4/</url>
    <content><![CDATA[<h4 id="Hello-World-不巧，我也在等你。"><a href="#Hello-World-不巧，我也在等你。" class="headerlink" title="Hello,World.不巧，我也在等你。"></a>Hello,World.不巧，我也在等你。</h4><p>​      有人说自己被社会磨平了棱角，泯灭了心性，受生活所迫，“都说是为生活所迫，生活缺从来没有被抓过；都说被社会磨去棱角，社会之恶至今无法逃脱”，我们都有权利选择自己想成为的人，并不是由社会说了算，我们都曾年少，我们都曾有棱角，社会的熔炉却在不断的炼化我们，到底是磨平了棱角，还是磨成了钢刀，就让时间来见证吧！</p>
<p>​      常年混迹于各大网络社区，也曾愤青，如今独爱云淡风轻，只愿在滚滚红尘中揽得风花雪月独醉。</p>
<h4 id="感谢你的到来。"><a href="#感谢你的到来。" class="headerlink" title="感谢你的到来。"></a>感谢你的到来。</h4><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/movejian/images/main/blog/images/8.jpg" alt="8"></p>
]]></content>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title>热血传奇幻境迷宫、屠龙殿、圣域地图走法图解</title>
    <url>/2022/08/31/%E7%83%AD%E8%A1%80%E4%BC%A0%E5%A5%87%E5%B9%BB%E5%A2%83%E8%BF%B7%E5%AE%AB%E3%80%81%E5%B1%A0%E9%BE%99%E6%AE%BF%E3%80%81%E5%9C%A3%E5%9F%9F%E5%9C%B0%E5%9B%BE%E8%B5%B0%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p>小编精心总结了热血传奇幻境从幻境一层—幻境迷宫—幻境十层—屠龙殿—圣域之门地图的全部走法攻略，通过图文解说+参考视频进行了详尽的描述，愿可以帮助到您。</p>
<h2 id="热血传奇幻境一层走法："><a href="#热血传奇幻境一层走法：" class="headerlink" title="热血传奇幻境一层走法："></a>热血传奇幻境一层走法：</h2><p>从幻境老人处花费金币进入。</p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310049612.jpeg" alt="img"></p>
<h2 id="热血传奇幻境二层："><a href="#热血传奇幻境二层：" class="headerlink" title="热血传奇幻境二层："></a>热血传奇幻境二层：</h2><p>幻一地图左上角，坐标（12：11）</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310049678.jpeg" alt="img"></p>
<h2 id="热血传奇幻境三层："><a href="#热血传奇幻境三层：" class="headerlink" title="热血传奇幻境三层："></a>热血传奇幻境三层：</h2><p>幻二地图右上角，坐标（362：230）</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310049989.jpeg" alt="img"></p>
<h2 id="热血传奇幻境四层走法："><a href="#热血传奇幻境四层走法：" class="headerlink" title="热血传奇幻境四层走法："></a>热血传奇幻境四层走法：</h2><p>幻三一直向右走….</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310050797.jpeg" alt="img"></p>
<p>坐标（83：83）点击幻境向导进入幻境四层</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310050225.jpeg" alt="img"></p>
<h2 id="热血传奇幻境五层走法："><a href="#热血传奇幻境五层走法：" class="headerlink" title="热血传奇幻境五层走法："></a>热血传奇幻境五层走法：</h2><p>幻境四层地图右上角（191：123）进入</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310050461.jpeg" alt="img"></p>
<h2 id="热血传奇幻境六层走法："><a href="#热血传奇幻境六层走法：" class="headerlink" title="热血传奇幻境六层走法："></a>热血传奇幻境六层走法：</h2><p>幻境五层地图下面坐标（38：228）进入</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310050589.jpeg" alt="img"></p>
<h2 id="热血传奇幻境七层走法："><a href="#热血传奇幻境七层走法：" class="headerlink" title="热血传奇幻境七层走法："></a>热血传奇幻境七层走法：</h2><p>幻境六层地图坐标（82：26）走到这附近会跳出来古墓尸王，他出来的那个坑走进去就进入幻境七层了。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310050736.jpeg" alt="img"></p>
<h2 id="热血传奇幻境迷宫入口："><a href="#热血传奇幻境迷宫入口：" class="headerlink" title="热血传奇幻境迷宫入口："></a>热血传奇幻境迷宫入口：</h2><p>幻境七层地图左上角（121：12）进入。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051440.jpeg" alt="img"></p>
<h2 id="幻境迷宫走法："><a href="#幻境迷宫走法：" class="headerlink" title="幻境迷宫走法："></a>幻境迷宫走法：</h2><h4 id="上——上——左——下——右——下，图中已标注具体方向。"><a href="#上——上——左——下——右——下，图中已标注具体方向。" class="headerlink" title="上——上——左——下——右——下，图中已标注具体方向。"></a>上——上——左——下——右——下，图中已标注具体方向。</h4><h2 id="热血传奇幻境八层走法："><a href="#热血传奇幻境八层走法：" class="headerlink" title="热血传奇幻境八层走法："></a>热血传奇幻境八层走法：</h2><p>幻境迷宫下一层进入</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051118.jpeg" alt="img"></p>
<h2 id="热血传奇幻境九层走法："><a href="#热血传奇幻境九层走法：" class="headerlink" title="热血传奇幻境九层走法："></a>热血传奇幻境九层走法：</h2><p>幻境八层左边（22：29）进入。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051707.jpeg" alt="img"></p>
<h2 id="热血传奇幻境十层屠龙殿走法："><a href="#热血传奇幻境十层屠龙殿走法：" class="headerlink" title="热血传奇幻境十层屠龙殿走法："></a>热血传奇幻境十层屠龙殿走法：</h2><p>幻境九层地图中上的位置坐标（151：105）进入，如图所示。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051054.jpeg" alt="img"></p>
<p>幻境十层屠龙殿…</p>
<h2 id="热血传奇圣域之门入口："><a href="#热血传奇圣域之门入口：" class="headerlink" title="热血传奇圣域之门入口："></a>热血传奇圣域之门入口：</h2><p>在幻十地图最右边（370：374）点击NPC进入。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051114.jpeg" alt="img"></p>
<h2 id="热血传奇圣域之门走法："><a href="#热血传奇圣域之门走法：" class="headerlink" title="热血传奇圣域之门走法："></a>热血传奇圣域之门走法：</h2><p>从幻十传送到圣域之门时坐标是随机的，这时候就需要用到随机传送卷了（如果有传送戒指更佳），将自己的坐标放到9：11周围，但不能在9：11上。</p>
<p>如图，我将自己坐标放在了9：10上，这时我向下走一步就进到圣域教主的房间里了。</p>
<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310051458.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>传奇</tag>
        <tag>幻境</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>继上一期解决github上的图片无法显示的问题</title>
    <url>/2022/08/21/%E7%BB%A7%E4%B8%8A%E4%B8%80%E6%9C%9F%E8%A7%A3%E5%86%B3github%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​      <a href="https://movejian.github.io/2022/08/19/vscode%E9%85%8D%E7%BD%AEpicgo%E7%9A%84github%E7%9A%84%E5%9B%BE%E5%BA%8A/">继上篇github图床问题</a>无法正常显示，但在<strong>github</strong>上看到正常上传，连接也并非错误，百度了一下说什么<strong>DNS</strong>被污染了。解决方法是修改<strong>hosts</strong>文件或者修改<strong>DNS</strong>。</p>
<p>​      首先，打开<a href="https://ping.eu/nslookup">域名解析</a>网站：<a href="https://ping.eu/nslookup">https://ping.eu/nslookup</a><br>然后输入raw.githubusercontent.com如下图：</p>
<p><img src="https://movejian.github.io/images/20220821/5.png"></p>
<span id="more"></span>
<p>​      我们得到图床所用域名解析到的IP(上图红框中的地址)。</p>
<ul>
<li>最后打开本机的<strong>host</strong>文件，其路径如下：<br><code>C:\Windows\System32\drivers\etc\hosts</code>, 然后添加如下内容(上图红框中的地址)：</li>
</ul>
<p><img src="https://movejian.github.io/images/20220821/6.png"></p>
<ul>
<li>打开<strong>CMD</strong>输入命令<code>ipconfig /flushdns</code>刷新<strong>DNS</strong>缓存,再次输入<code>ipconfig/displaydns</code></li>
</ul>
<p>​    如果你的<strong>hosts</strong>的文件不见了,可以通过文件设置显示系统隐藏文件来找到，依然找不到，可能是被误删了，网上有很多是通过新建文本文档解决。也可以通过下面这个命令来生成<strong>hosts</strong>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /f %P in (&#x27;dir %windir%\WinSxS\hosts /b /s&#x27;) do copy %P %windir%\System32\drivers\etc &amp; echo %P &amp; Notepad %P</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>一定要使用管理员身份输入此命令。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>热血传奇魔龙地图与简易图解</title>
    <url>/2022/08/31/%E7%83%AD%E8%A1%80%E4%BC%A0%E5%A5%87%E9%AD%94%E9%BE%99%E5%9C%B0%E5%9B%BE%E4%B8%8E%E7%AE%80%E6%98%93%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p>盟重老兵（325，325）处可以直接传送到魔龙城。 魔龙城的怪物有：魔龙血蛙、魔龙破甲兵、魔龙射手、魔龙教主等。</p>
<p>热血传奇每张主城地图都有一段传奇背景故事，而180版本更新的魔龙城地图就没有啥背景故事，后面出来的背景故事也是一些写手编写的各种版本。据说韩版里面魔龙城是上古比奇城，这也是为何传奇中魔龙城只有通过传送才能去的原因。如下图，魔龙城的外观跟比奇城的外观都差不多</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310151686.jpg"></p>
<p>说完了背景来源，咱们说说魔龙城的更新地位。作为合击版本的新地图，这里地图更多，怪物更强，产出的装备也越好。魔龙地图的BOSS也就是被誉为玛法最强BOSS的–魔龙教主。魔龙教主可以掉落开天系列，凤天系列，42级衣服，战神，圣魔，真魂系列，魔龙首饰等等。老道以前跟朋友组队去打过 ，想着不爆玄天了，爆个逍遥扇也快活的，可惜没爆啥好东西。</p>
<h3 id="大图拼接"><a href="#大图拼接" class="headerlink" title="大图拼接"></a>大图拼接</h3><p><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/%E9%AD%94%E9%BE%99%E5%85%A8%E5%9B%BE.webp"></p>
<h3 id="简易图解"><a href="#简易图解" class="headerlink" title="简易图解"></a>简易图解</h3><img src="https://raw.githubusercontent.com/movejian/images/main/movejian/images202208310151382.jpg" style="zoom:50%;" />

<h2 id="魔龙东郊到魔龙血域"><a href="#魔龙东郊到魔龙血域" class="headerlink" title="魔龙东郊到魔龙血域"></a>魔龙东郊到魔龙血域</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">魔龙东郊入口</td>
<td align="center">471，375</td>
<td align="center">魔龙东郊&gt;&gt;魔龙城</td>
<td align="center">35，132</td>
</tr>
<tr>
<td align="center">东郊&gt;&gt;东林间胜地</td>
<td align="center">164，393</td>
<td align="center">东林间胜地&gt;&gt;东郊</td>
<td align="center">28，147</td>
</tr>
<tr>
<td align="center">东林间&gt;&gt;魔龙旧寨</td>
<td align="center">172，150</td>
<td align="center">魔龙旧寨&gt;&gt;东林间</td>
<td align="center">60，467</td>
</tr>
<tr>
<td align="center">魔龙旧寨&gt;&gt;魔龙祭坛</td>
<td align="center">165，57</td>
<td align="center">魔龙祭坛&gt;&gt;魔龙旧寨</td>
<td align="center">47，45</td>
</tr>
<tr>
<td align="center">魔龙祭坛&gt;&gt;魔龙岭</td>
<td align="center">173，170</td>
<td align="center">魔龙岭&gt;&gt;魔龙祭坛</td>
<td align="center">26，368</td>
</tr>
<tr>
<td align="center">魔龙岭&gt;&gt;魔龙沼泽</td>
<td align="center">258，366</td>
<td align="center">魔龙沼泽&gt;&gt;魔龙岭</td>
<td align="center">263，38</td>
</tr>
<tr>
<td align="center">魔龙岭&gt;&gt;东魔龙关</td>
<td align="center">249，36</td>
<td align="center">东魔龙关&gt;&gt;魔龙岭</td>
<td align="center">161，168</td>
</tr>
<tr>
<td align="center">东魔龙关&gt;&gt;魔龙血域</td>
<td align="center">26，37</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="东郊走法"><a href="#东郊走法" class="headerlink" title="东郊走法"></a>东郊走法</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">入口</td>
<td align="center">460，66</td>
<td align="center">魔龙西郊&gt;&gt;魔龙城</td>
<td align="center">32，46</td>
</tr>
<tr>
<td align="center">西郊&gt;&gt;西林间胜地</td>
<td align="center">288，284</td>
<td align="center">西林间胜地&gt;&gt;西郊</td>
<td align="center">31，117</td>
</tr>
<tr>
<td align="center">西郊&gt;&gt;魔龙旧寨</td>
<td align="center">347，53</td>
<td align="center">魔龙旧寨&gt;&gt;西郊</td>
<td align="center">135，429</td>
</tr>
<tr>
<td align="center">西林间&gt;&gt;魔龙沼泽</td>
<td align="center">369，140</td>
<td align="center">魔龙沼泽&gt;&gt;西林间</td>
<td align="center">33，264</td>
</tr>
</tbody></table>
<p>魔龙血域走法：魔龙城（472，376）→魔龙东郊（162，390）→东林间胜地（169，148）→魔龙旧寨（161，55）→魔龙祭坛（170，173）→魔龙岭（250，41）→魔龙东关（30，35）→魔龙谷（40，64）→龙源血路（50，161）→魔龙血域。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>传奇</tag>
        <tag>攻略</tag>
        <tag>魔龙</tag>
      </tags>
  </entry>
  <entry>
    <title>自动备份Hexo博客源文件</title>
    <url>/2022/08/21/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>自从接触了Hexo+NexT之后，发现离不开了，以后有能力的时候一定重新架构一下，使得更加个性化，最大程度的满足我们对于软件的需求，大家都知道，如果写东西在本地的话，最怕的应该就是更换电脑，还要重新搭建博客了，所以备份对于我们来说特别重要！备份博客就是本篇博客文章的主旨了，一定要攻下这座城堡。</p>
<p>我曾经看过Git备份Hexo博客源文件的方式，这种方式虽然能够备份Hexo博客的源文件，但是对于我这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。况且指不定哪天就搞忘push到github上了。你说是不是，所以这篇文章出现了……</p>
<span id="more"></span>
<h3 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h3><p>通过监听Hexo的事件来完成自动执行Git命令进行自动备份，查阅Hexo文档，找到了Hexo的主要事件，见下表：</p>
<table>
<thead>
<tr>
<th>事件名</th>
<th>事件发生时间</th>
</tr>
</thead>
<tbody><tr>
<td>deployBefore</td>
<td>在部署完成前发布</td>
</tr>
<tr>
<td>deployAfter</td>
<td>在部署成功后发布</td>
</tr>
<tr>
<td>exit</td>
<td>在 Hexo 结束前发布</td>
</tr>
<tr>
<td>generateBefore</td>
<td>在静态文件生成前发布</td>
</tr>
<tr>
<td>generateAfter</td>
<td>在静态文件生成后发布</td>
</tr>
<tr>
<td>new</td>
<td>在文章文件建立后发布</td>
</tr>
</tbody></table>
<p>于是我们就可以通过监听Hexo的deployAfter事件，待上传完成之后自动运行Git备份命令，从而达到自动备份的目的。</p>
<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><h5 id="1-将Hexo目录加入Git仓库"><a href="#1-将Hexo目录加入Git仓库" class="headerlink" title="1.将Hexo目录加入Git仓库"></a>1.将Hexo目录加入Git仓库</h5><p>本脚本需要提前将Hexo加入Git仓库并与Github或者Gitee远程仓库绑定之后，才能正常工作。如果你不知道该怎样进行操作，可以参考我的另一篇博文：</p>
<ul>
<li>Git命令手动备份Hexo博客源文件</li>
</ul>
<h5 id="2-安装shelljs模块"><a href="#2-安装shelljs模块" class="headerlink" title="2.安装shelljs模块"></a>2.安装shelljs模块</h5><p>要实现这个自动备份功能，需要依赖NodeJs的一个shelljs模块,该模块重新包装了child_process,调用系统命令更加的方便。（其实就是因为我懒( ╯▽╰)）该模块需要安装后使用。</p>
<p>在命令中键入以下命令，完成shelljs模块的安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save shelljs</span><br></pre></td></tr></table></figure>

<h5 id="3-编写自动备份脚本"><a href="#3-编写自动备份脚本" class="headerlink" title="3.编写自动备份脚本"></a>3.编写自动备份脚本</h5><p>shelljs模块安装完成后，在Hexo根目录的scripts文件夹下新建一个js文件，文件名随意取(我的文件名为:auto_backup.js)。如果没有scripts目录，请新建一个。</p>
<p>然后在脚本中，写入以下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">require(<span class="string">&#x27;shelljs/global&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    hexo.on(<span class="string">&#x27;deployAfter&#x27;</span>, function() &#123;//当deploy完成后执行备份</span><br><span class="line">        run();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;产生了一个错误啊&lt;(￣3￣)&gt; !，错误详情为：&quot;</span> + e.toString());</span><br><span class="line">&#125;</span><br><span class="line">function run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!which(<span class="string">&#x27;git&#x27;</span>)) &#123;</span><br><span class="line">        echo(<span class="string">&#x27;Sorry, this script requires git&#x27;</span>);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        echo(<span class="string">&quot;======================Auto Backup Begin===========================&quot;</span>);</span><br><span class="line">        cd(<span class="string">&#x27;E:/work/myblog&#x27;</span>);    //此处修改为Hexo根目录路径</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exec</span>(<span class="string">&#x27;git add --all&#x27;</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">            echo(<span class="string">&#x27;Error: Git add failed&#x27;</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exec</span>(<span class="string">&#x27;git commit -am &quot;blog auto backup script\&#x27;s commit&quot;&#x27;</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">            echo(<span class="string">&#x27;Error: Git commit failed&#x27;</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exec</span>(<span class="string">&#x27;git push origin master&#x27;</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">            echo(<span class="string">&#x27;Error: Git push failed&#x27;</span>);</span><br><span class="line">            exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        echo(<span class="string">&quot;==================Auto Backup Complete============================&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，需要修改第16行的<code>E:/work/myblog</code>路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）</li>
<li>如果你的Git远程仓库名称不为<code>origin</code>的话，还需要修改第25行执行的push命令，修改成自己的远程仓库名和相应的分支名。</li>
</ul>
<h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p>保存脚本并退出，然后执行hexo d命令，在常规结果执行出来后，将会得到类似以下结果:</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
